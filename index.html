<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="还有什么比不浪费时间更有意义的事呢？">
<meta property="og:type" content="website">
<meta property="og:title" content="mashell">
<meta property="og:url" content="http://mashell.cn/index.html">
<meta property="og:site_name" content="mashell">
<meta property="og:description" content="还有什么比不浪费时间更有意义的事呢？">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mashell">
<meta name="twitter:description" content="还有什么比不浪费时间更有意义的事呢？">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://mashell.cn/"/>


  <title> mashell </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">mashell</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">你热爱生命吗？那别浪费时间</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="http://mashell.cn/resume/" rel="section">
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/08/ContentProvider-启动流程/" itemprop="url">
                  ContentProvider 启动流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-08T16:40:47+08:00" content="2018-04-08">
              2018-04-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/08/ContentProvider-启动流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/08/ContentProvider-启动流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/04/08/ContentProvider-启动流程/" class="leancloud_visitors" data-flag-title="ContentProvider 启动流程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在分析 Activity 的启动流程的时候说过,如果不存在对应的进程,<code>Zygote</code>会<code>fork</code>出一个新进程,然后反射出<code>ActivityThread</code>,执行<code>main()</code>函数,这也是应用的入口.在<code>main()</code>函数中,会调用<code>AMS.attachApplication()</code>,这个方法会先执行<code>ActivityThread.bindApplication</code>,然后通过<code>H.sendMessage() H.handleMessage()</code>,最终执行到<code>handleBindApplication</code>,这个方法会先<code>makeApplication</code>反射创建一个Application对象,然后调用<code>installContentProviders()</code>创建加载 ContentProvider,最后才执行<code>Application.onCreate()</code></p>
<p><strong>ContentProvider的onCreate 要早执行于 Application.onCreate()</strong></p>
<h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>我们使用 ContentProvider 的时候,需要通过 ContentResolver,它是一个抽象类,具体的实现类是<code>ApplicationContentResolver</code>(它是ContextImpl的静态内部类),它继承自ContentResolver并且实现了抽象方法.当ContentProvider所在的进程未被启动时(没有其他App使用过该ContentProvider),这时第一次访问(增删改查)就会触发ContentProvider 的创建.我们看一下如何触发的,比如 query</p>
<h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>我们调用 <code>getResolver().query()</code>,最终会到<code>ContentResolver.query()</code>,他会判断<code>acquireProvider(uri);</code>是否加载过该ContentProvider,该方法的具体实现是<code>ContextImpl.ApplicationContentResolver.acquireProvider()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected IContentProvider acquireProvider(Context context, String auth) &#123;</div><div class="line">    return mMainThread.acquireProvider(context,</div><div class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</div><div class="line">            resolveUserIdFromAuthority(auth), true);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mMainThread也就是<code>ActivityThread</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public final IContentProvider acquireProvider(</div><div class="line">            Context c, String auth, int userId, boolean stable) &#123;</div><div class="line">        //尝试在已加载列表中找该contentProvider</div><div class="line">        final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</div><div class="line">        if (provider != null) &#123;</div><div class="line">            return provider;</div><div class="line">        &#125;</div><div class="line">        ContentProviderHolder holder = null;</div><div class="line">        try &#123;</div><div class="line">        //在列表中没找到,就通知 AMS 启动 ContentProvider</div><div class="line">            holder = ActivityManager.getService().getContentProvider(</div><div class="line">                    getApplicationThread(), auth, userId, stable);</div><div class="line">        &#125; catch (RemoteException ex) &#123;</div><div class="line">            throw ex.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        //加载 contentProvider</div><div class="line">        holder = installProvider(c, holder, holder.info,</div><div class="line">                true /*noisy*/, holder.noReleaseNeeded, stable);</div><div class="line">        return holder.provider;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">----------------acquireExistingProvider-----------</div><div class="line">public final IContentProvider acquireExistingProvider(</div><div class="line">            Context c, String auth, int userId, boolean stable) &#123;</div><div class="line">        synchronized (mProviderMap) &#123;</div><div class="line">        //是一个 ArrayMap</div><div class="line">            final ProviderClientRecord pr = mProviderMap.get(key);</div><div class="line">            //Map 中没找到返回null</div><div class="line">            if (pr == null) &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到,ActivityThread维护了一个ArrayMap保存已经加载过的ContentProvider,我们获取ContentProvider的时候首先回去ArrayMap中找,找不到的话再通知<code>AMS</code>启动对应ContentProvider</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">------------------AMS.getContentProvider-------------</div><div class="line">private ContentProviderHolder getContentProviderImpl(IApplicationThread caller,</div><div class="line">            String name, IBinder token, boolean stable, int userId) &#123;</div><div class="line">    ...</div><div class="line">    //尝试获取对应的进程</div><div class="line">    ProcessRecord proc = getProcessRecordLocked(...);</div><div class="line">    if(proc != null)&#123;</div><div class="line">        ...</div><div class="line">    &#125; else &#123;</div><div class="line">    //进程还未加载,那么 startProcessLocked 创建进程</div><div class="line">         proc = startProcessLocked(...);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 AMS 的getContentProvider中,会获取对应的进程,没有启动过对应进程的话,会用<code>startProcessLocked()</code>创建进程,这个方法我们在 <code>Activity 的启动流程</code> 分析过,大致就是<code>Zygote fork 新进程</code>,然后反射出<code>ActivityThread</code>对象,调用<code>ActivityThread.main()</code>方法</p>
<h4 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread.main()"></a>ActivityThread.main()</h4><p>main()大致流程如下</p>
<ul>
<li><strong>ActivityThread</strong>.attach()</li>
<li><strong>AMS</strong>.attachApplication()</li>
<li><strong>ActivityThread</strong>.bindApplication()</li>
<li><strong>ActivityThread.H</strong>.sendMessage()</li>
<li><strong>ActivityThread.H</strong>.handleMessage()</li>
<li><strong>ActivityThread</strong>.handleBindApplication()</li>
</ul>
<h4 id="ActivityThread-handleBindApplication"><a href="#ActivityThread-handleBindApplication" class="headerlink" title="ActivityThread.handleBindApplication()"></a>ActivityThread.handleBindApplication()</h4><p>这个方法比较重要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private void handleBindApplication(AppBindData data) &#123;</div><div class="line">    ...</div><div class="line">    //创建 ContextImpl 对象</div><div class="line">    final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);</div><div class="line">    //通过反射创建 Instrumentation,用于 组件的生命周期管理</div><div class="line">    final ClassLoader cl = instrContext.getClassLoader();</div><div class="line">    mInstrumentation = (Instrumentation)</div><div class="line">        cl.loadClass(data.instrumentationName.getClassName()).newInstance();</div><div class="line">    ...</div><div class="line">    //makeApplication会调用 mInstrumentation.newApplication</div><div class="line">    //反射创建 Application 对象</div><div class="line">    //newApplication 内部会调用 Application.attach()</div><div class="line">    //由于 makeApplication( instrumentation = null)</div><div class="line">    //不会先执行 Application.onCreate</div><div class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, null);</div><div class="line">    ...</div><div class="line">    //加载 ContentProvider</div><div class="line">    installContentProviders(app, data.providers);</div><div class="line">    //调用Application的 onCreate</div><div class="line">    mInstrumentation.callApplicationOnCreate(app);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-----------------installContentProviders()----------------</div><div class="line"></div><div class="line">private void installContentProviders(</div><div class="line">            Context context, List&lt;ProviderInfo&gt; providers) &#123;</div><div class="line">    for (ProviderInfo cpi : providers) &#123;</div><div class="line">    //依次加载 ContentProvider</div><div class="line">        ContentProviderHolder cph = installProvider(context, null, cpi,</div><div class="line">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</div><div class="line">    &#125;</div><div class="line">     ...</div><div class="line">     //通知 AMS 加载过那些 ContentProvider</div><div class="line">     ActivityManager.getService().publishContentProviders(</div><div class="line">                    getApplicationThread(), results);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到,在<code>handleBindApplication()</code>中,创建了 <code>ContextImpl</code>,<code>Application</code>对象,然后调用了 installProvider(),最后才执行 Application.onCreate()</p>
<p>ContentProvider 具体的启动流程就是在 <code>installProvider()</code>里面了</p>
<h4 id="ContentProviderHolder-installProvider"><a href="#ContentProviderHolder-installProvider" class="headerlink" title="ContentProviderHolder.installProvider()"></a>ContentProviderHolder.installProvider()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private ContentProviderHolder installProvider(...) &#123;</div><div class="line">    ...</div><div class="line">    final java.lang.ClassLoader cl = c.getClassLoader();</div><div class="line">    //通过反射创建 ContentProvider 对象</div><div class="line">    localProvider = (ContentProvider)cl.</div><div class="line">        loadClass(info.name).newInstance();</div><div class="line">    provider = localProvider.getIContentProvider();</div><div class="line">    ...</div><div class="line">    //调用 attachInfo,内部是调用了 onCreate</div><div class="line">    localProvider.attachInfo(c, info);        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ContentProvider 也是跟Activity以及Application一样,通过反射得到的对象,对象创建完成后调用 ContentProvider.onCreate 方法</p>
<h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><p>我们通过Binder机制,知道其他应用获取的Binder对象是<code>IContentProvider</code>,他的具体实现类是<code>ContentProvider.Transport</code>我们远程段调服务端方法,实际上是调用<code>ContentProvider.Transport.query()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Transport extends ContentProviderNative &#123;</div><div class="line">     public Cursor query()&#123;</div><div class="line">        Cursor cursor = ContentProvider.this.query(</div><div class="line">                        uri, projection, queryArgs,</div><div class="line">                        CancellationSignal.fromTransport(cancellationSignal));</div><div class="line">        ...</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到,最终还是调用回了自身<code>ContentProvider</code>对应的query()方法,而这个方法是抽象方法,需要我们继承<code>ContentProvider</code>去具体实现的.这样当我们执行的结果就会通过 Binder返回给客户端了.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/02/invalidate-requestLayout与ViewGroup-draw/" itemprop="url">
                  Invalidate 与 requestLayout,ViewGroup.draw() 区别与联系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-02T15:33:44+08:00" content="2018-04-02">
              2018-04-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/02/invalidate-requestLayout与ViewGroup-draw/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/02/invalidate-requestLayout与ViewGroup-draw/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/04/02/invalidate-requestLayout与ViewGroup-draw/" class="leancloud_visitors" data-flag-title="Invalidate 与 requestLayout,ViewGroup.draw() 区别与联系">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h2><ul>
<li><code>requestLayout</code> 会调用 <code>ViewGroup 的 requestLayout</code>,直到 <code>ViewRootImpl</code> 的 <code>requestLayout</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void requestLayout() &#123;</div><div class="line">        if (mMeasureCache != null) mMeasureCache.clear();</div><div class="line"></div><div class="line">        if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123;</div><div class="line">           </div><div class="line">            ViewRootImpl viewRoot = getViewRootImpl();</div><div class="line">            if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123;</div><div class="line">                if (!viewRoot.requestLayoutDuringLayout(this)) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            mAttachInfo.mViewRequestingLayout = this;</div><div class="line">        &#125;</div><div class="line">        //将当前 标志 设置 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED</div><div class="line">        mPrivateFlags |= PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags |= PFLAG_INVALIDATED;</div><div class="line">        //调用父类的requestLayout，父类也会被设置标志 PFLAG_FORCE_LAYOUT</div><div class="line">        if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;</div><div class="line">            mParent.requestLayout();</div><div class="line">        &#125;</div><div class="line">        if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123;</div><div class="line">            mAttachInfo.mViewRequestingLayout = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>ViewRootImpl 的 requestLayout 最终会执行<code>performTravels()</code>,会依次调用<code>measure(),layout(),draw()</code>三个方法</p>
<h3 id="measure"><a href="#measure" class="headerlink" title="measure()"></a>measure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">       ...</div><div class="line">       //判断是否设置了标志位 PFLAG_FORCE_LAYOUT,requestLayout 设置了</div><div class="line">        final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if (forceLayout || needsLayout) &#123;</div><div class="line">            ...</div><div class="line">            //由于设置了标志位,所以执行 onMeaure()</div><div class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">               ...</div><div class="line">                ...</div><div class="line">        //设置了 PFLAG_LAYOUT_REQUIRED, layout 中有作用</div><div class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以看到,由于我们 requestLayout 设置了 <code>PFLAG_FORCE_LAYOUT</code>,所以在 measure 会执行 <code>onMeasure()</code>方法,该方法末尾设置了标志位 <code>PFLAG_LAYOUT_REQUIRED</code></p>
</blockquote>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">        ...</div><div class="line">        //如果view布局变了,setFrame 会返回 true</div><div class="line">        boolean changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line">        //如果布局变了,或者设置了 PFLAG_LAYOUT_REQUIRED,则执行 onLayout</div><div class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            //在执行完onLayout方法之后，从mPrivateFlags中移除标签PFLAG_LAYOUT_REQUIRED</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line">            &#125;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在 layout 方法中,由于我们在 meaesure 设置了 <code>PFLAG_LAYOUT_REQUIRED</code>,所以会执行 onLayout() 方法</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>在 requestLayout 过程中，View 以及 父View 不断被设置标志 <code>PFLAG_FORCE_LAYOUT</code>,View 还设置了<code>PFLAG_INVALIDATED</code>,那么最后 performTravel时，<code>measure</code>检测到了标志位，一定会 <code>measure</code>，*</strong></li>
<li><strong>调用了 measure().该方法最后会设置 <code>PFLAG_FORCE_LAYOUT</code>,所以layout()会执行<code>onLayout()</code>方法</strong></li>
<li>调用 <code>requestLayout</code>的View以及他的父View <strong>都会进行 measure(),layout()</strong></li>
<li>对于 onDraw 会否执行,分两种情况<ul>
<li>如果<code>requestLayout</code>过程,layout没有改变<code>l,t,r,b</code>那么在 <code>performDraw</code>过程中，<code>mDirty</code>为空，所以onDraw不会被执行</li>
<li>如果<code>requestLayout</code>过程,layout导致<code>l,t,r,b</code>不一样了,那么在<strong>setFrame</strong>中,会调用<code>invalidate()</code>(源码太长不展示了),从而执行 <code>onDraw</code>.</li>
</ul>
</li>
</ul>
<h2 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h2><ul>
<li>我们调用 <code>invalidate</code> 方法，最终调用到<code>invalidateInternal</code>.他会设置两个标志位<code>FLAG_INVALIDATED</code>和<code>PFLAG_DRAWING_CACHE_VALID</code>，<code>PFLAG_INVALIDATED</code>置为 <strong>1</strong>，<code>PFLAG_DRAWING_CACHE_VALID</code>置为<strong>0</strong>.  。 接着会调用 父View 的 <code>invalidateChild</code></li>
<li><code>invalidateChild</code>,它里面是一个 while 循环，一直遍历查找 父View，调用 <code>ViewGroup的invalidateChild()</code>。,进而调用<code>invalidateChildInParent()</code>,<strong>该方法清除了 PFLAG_DRAWING_CACHE_VALID 标志</strong>，他们的标志位都会设置<code>PFLAG_DRAWING_CACHE_VALID置为0</code>。(为了筛选出View所在的链，排除其他无关链)</li>
<li>最终，会执行到 <code>ViewRoot</code> 的 <code>invalidateChildInParent</code></li>
<li>在 <code>ViewRoot</code> 的 <code>invalidateChildInParent</code> 中，会调用 <code>scheduleTraversals</code></li>
<li><code>scheduleTraversals</code> <strong>由于没有<code>PFLAG_FORCE_LAYOUT</code>,所以不会调用 <code>measure()</code> 进而不会调用<code>layout()</code>,</strong> 最终进入<code>performDraw()</code>执行<code>mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this);</code></li>
<li><code>draw(mView, mAttachInfo, this)</code>会调用<code>ThreadedRenderer.updateRootDisplayList() -&gt; ThreadedRenderer.updateViewTreeDisplayList() -&gt; View.updateDisplayListIfDirty()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private void updateViewTreeDisplayList(View view) &#123;</div><div class="line">        view.mPrivateFlags |= View.PFLAG_DRAWN;</div><div class="line">        //这里根据 PFLAG_INVALIDATED 设置了 mRecreateDisplayList</div><div class="line">        //如果是需要重绘的View,那么 mRecreateDisplayList 此时就会设置为 true</div><div class="line">        //其他view 依旧false</div><div class="line">        view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)</div><div class="line">                == View.PFLAG_INVALIDATED;</div><div class="line">        view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;</div><div class="line">        //进行更新视图操作,内部是根据情况调用 draw 方法</div><div class="line">        view.updateDisplayListIfDirty();</div><div class="line">        //调用结束,清除设置的状态 false</div><div class="line">        view.mRecreateDisplayList = false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们前面设置了 view 的<code>PFLAG_INVALIDATED</code>为1,<code>PFLAG_DRAWING_CACHE_VALID</code>为0.他的 parentView 为<code>PFLAG_DRAWING_CACHE_VALID</code>和<code>PFLAG_INVALIDATED</code>都为0. <strong>这样我们可以通过 PFLAG_DRAWING_CACHE_VALID 找到那条View链是有关联系,然后通过<code>PFLAG_INVALIDATED</code>知道了哪个View需要重绘</strong>,重绘View.mRecreateDisplayList 为 true</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public RenderNode updateDisplayListIfDirty() &#123;</div><div class="line">        final RenderNode renderNode = mRenderNode;</div><div class="line">        ...</div><div class="line">        // PFLAG_DRAWING_CACHE_VALID 前面设置的标志位,</div><div class="line">        // 表示这条链与需要重绘的View有关</div><div class="line">        if ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0</div><div class="line">                || !renderNode.isValid()</div><div class="line">            //mRecreateDisplayList 表示不是重绘view本身</div><div class="line">            if (renderNode.isValid()</div><div class="line">                    &amp;&amp; !mRecreateDisplayList) &#123;</div><div class="line">                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</div><div class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</div><div class="line">                //继续分发事件,循环调用childView.recreateChildDisplayList()</div><div class="line">                //最终还是调用 view.updateDisplayListIfDirty()</div><div class="line">                dispatchGetDisplayList();</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">            //走到这里,mRecreateDisplayList = true,是重绘view本身</div><div class="line">                if (layerType == LAYER_TYPE_SOFTWARE) &#123;</div><div class="line">                    ...</div><div class="line">                &#125; else &#123;</div><div class="line">                    ...</div><div class="line">                    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</div><div class="line">                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</div><div class="line">                    </div><div class="line">                    if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</div><div class="line">                        //重绘 View 是 ViewGroup,而且 PFLAG_SKIP_DRAW 直接绘制子View</div><div class="line">                        dispatchDraw(canvas);</div><div class="line">                        ...</div><div class="line">                    &#125; else &#123;</div><div class="line">                        //绘制view本身</div><div class="line">                        draw(canvas);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; </div><div class="line">            ...</div><div class="line">        &#125; else &#123;</div><div class="line">            ...</div><div class="line">            //不是 view 本身,也不是View相关父View,直接结束</div><div class="line">        &#125;</div><div class="line">        return renderNode;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>可以看到,绘制方法通过<code>PFLAG_DRAWING_CACHE_VALID</code>找到了有关联的View链,然后通过<code>PFLAG_INVALIDATED</code>找到了具体需要重绘的那个View,有以下几种情况</strong><ul>
<li><code>重绘View</code>本身,<code>PFLAG_DRAWING_CACHE_VALID = 0</code>而且<code>PFLAG_INVALIDATED = 1</code>.那么走到 <code>draw(canvas)</code>进行绘制.</li>
<li><code>重绘View的父View</code>,<code>PFLAG_DRAWING_CACHE_VALID = 0</code>,那么走到 <code>dispatchGetDisplayList()</code>继续分发事件给子View,最终还是回到<code>updateDisplayListIfDirty()</code></li>
<li>其他View链上的View,<code>PFLAG_DRAWING_CACHE_VALID = 1</code>,直接结束</li>
</ul>
</li>
</ul>
<p><strong>但是整个过程中，View没有强制重新测量的标志位 <code>PFLAG_FORCE_LAYOUT</code>,所以不会执行 <code>measure</code> 方法，没有进入 measure 方法，也就不会设置 <code>PFLAG_LAYOUT_REQUIRED</code>,那么在 <code>onLayout</code> 方法中，也就不会执行 onLayout 进行重新布局了</strong></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>invalidate 的实现依靠两个标志位</p>
<ul>
<li>PFLAG_DRAWING_CACHE_VALID</li>
<li>PFLAG_INVALIDATED</li>
</ul>
<p><strong>PFLAG_INVALIDATED 来判断哪个View 需要重绘，只有它会进行重绘，而<code>PFLAG_DRAWING_CACHE_VALID</code>用于判断是否继续分发，不是 View 所在的 View链，不会进行分发，节省时间。</strong></p>
<h2 id="ViewGroup-draw"><a href="#ViewGroup-draw" class="headerlink" title="ViewGroup.draw()"></a>ViewGroup.draw()</h2><p>对于 <code>draw(canvas)</code>,会在<code>performTraversals() -&gt; performDraw() -&gt; mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this); -&gt; ThreadedRenderer.updateRootDisplayList() -&gt; ThreadedRenderer.updateViewTreeDisplayList() -&gt; View.updateDisplayListIfDirty()</code>被调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void updateDisplayListIfDirty()&#123;</div><div class="line">if (!hasDisplayList) &#123; //软件绘制</div><div class="line">    // Fast path for layouts with no backgrounds</div><div class="line">    if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;      </div><div class="line">        //跳过当前View的绘制,直接绘制子view</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</div><div class="line">        dispatchDraw(canvas);</div><div class="line">    &#125; else &#123;                            </div><div class="line">        //此时坐标系已经切换到View自身坐标系了,可以纯碎的绘制当前view了,又回到了draw(canvas)</div><div class="line">        draw(canvas);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到,会判断当前View是否需要绘制(通过<code>PFLAG_SKIP_DRAW</code>标志).</p>
<ul>
<li>若 mPrivateFlags <strong>包含</strong><code>PFLAG_SKIP_DRAW</code>,那么直接<strong>跳过</strong>当前View的<code>draw(canvas)</code>,直接调用<code>dispatchDraw</code>绘制当前View的子View</li>
<li>若 mPrivateFlags <strong>不包含</strong><code>PFLAG_SKIP_DRAW</code>,那么会<strong>调用</strong> draw 方法</li>
</ul>
<p>而对于 ViewGroup 初始化的时候,他会调用 <code>initViewGroup()</code> 方法 ,会初始化一些 Flag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private void initViewGroup() &#123;</div><div class="line">    // ViewGroup doesn&apos;t draw by default</div><div class="line">    if (!debugDraw()) &#123;</div><div class="line">        setFlags(WILL_NOT_DRAW, DRAW_MASK);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于 <code>setFlags()</code> 方法,从源码中(篇幅太长不贴源码)可以看出,如果<strong>有 WILL_NOT_DRAW或者当前View没有背景</strong>,那么就会设置 <strong>PFLAG_SKIP_DRAW</strong>标志位,而这个标志位在 <code>draw(Canvas canvas, ViewGroup parent, long drawingTime) -&gt; ThreadedRenderer.updateRootDisplayList()  -&gt; ThreadedRenderer.updateViewTreeDisplayList() -&gt; View.updateDisplayListIfDirty()</code>方法中进行了判断,从而选择是否绘制本身</p>
<blockquote>
<p>所以可以看到,因为 <code>WILL_NOT_DRAW</code>标志位,所以ViewGroup 默认不执行 draw() 方法</p>
</blockquote>
<h3 id="setWillNotDraw"><a href="#setWillNotDraw" class="headerlink" title="setWillNotDraw"></a>setWillNotDraw</h3><p>View 还有一个重要的方法,来设置清除上面的标志位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void setWillNotDraw(boolean willNotDraw) &#123;  </div><div class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们想调用 ViewGroup 的 <code>draw(canvas)</code> 方法,我们得调用<code>setWillNotDraw(false)</code>来手动清除 <code>FALG</code>,以达到目的.</p>
<h3 id="ViewGroup-onDraw"><a href="#ViewGroup-onDraw" class="headerlink" title="ViewGroup.onDraw()"></a>ViewGroup.onDraw()</h3><p>在 View 的 <code>draw</code> 方法中,有一个标志位,他来判断是否需要 onDraw()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void draw(Canvas canvas) &#123;</div><div class="line">    final int privateFlags = mPrivateFlags;</div><div class="line">    final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">    ...</div><div class="line">    //判断是否需要调用 onDraw</div><div class="line">    if (!dirtyOpaque) onDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以说,即使 <code>draw()</code> 调用了,<code>onDraw()</code>也不一定执行,他必须满足 <code>dirtyOpaque = false</code> 也就是没有设置 <code>PFLAG_DIRTY_OPAQUE</code>,这个 flag 相关逻辑在<code>ViewGroup.invalidateChild()</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//这里的child表示直接调用invalidate的子View。</div><div class="line">public final void invalidateChild(View child, final Rect dirty) &#123;</div><div class="line">//计算子View是否是实心的</div><div class="line">final boolean isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp; child.getAnimation() == null &amp;&amp; childMatrix.isIdentity();</div><div class="line">//PFLAG_DIRTY和PFLAG_DIRTY_OPAQUE是互斥的</div><div class="line">int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</div><div class="line"></div><div class="line">do &#123; //循环遍历到ViewRootImpl为止</div><div class="line">    View view = null;//父View</div><div class="line">    if (parent instanceof View) &#123;</div><div class="line">        view = (View) parent;</div><div class="line">    &#125;</div><div class="line">    if (view != null) &#123; //给当前父View打上相应的flag</div><div class="line">        //父View若包含FADING_EDGE_MASK标识，那么只能打上FLAG_DIRTY标识</div><div class="line">        //表示会调用ViewGroup.onDraw方法</div><div class="line">        if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp;</div><div class="line">                            view.getSolidColor() == 0) &#123;</div><div class="line">            opaqueFlag = PFLAG_DIRTY;</div><div class="line">        &#125;</div><div class="line">        if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</div><div class="line">            //父View 不包含 FADING_EDGE_MASK标识</div><div class="line">            //那么打上 PFLAG_DIRTY_OPAQUE</div><div class="line">            //PFLAG_DIRTY和PFLAG_DIRTY_OPAQUE是互斥的</div><div class="line">            view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PFLAG_DIRTY和PFLAG_DIRTY_OPAQUE是互斥的</p>
<p>可以看到, View.invalidate 会最终调用到<code>ViewRootImpl的方法</code>,若子View是实心的,<strong>会将父控件标记为 <code>PFLAG_DIRTY_OPAQUE</code></strong>,否则为<code>PFLAG_DIRTY</code>,对于<code>PFLAG_DIRTY_OPAQUE</code>的View,绘制过程中,<strong>会跳过 <code>drawBackgroud() 和onDraw()</code>方法</strong>(分析<code>draw(canvas)</code>说过)</p>
<p><strong>PFLAG_DIRTY 会导致跳过 drawBackgroud 和 onDraw() 方法,这个标志对于 子View 的父ViewGroup有用,这样就能保证实心的View不多余的绘制父类部分</strong></p>
<h4 id="computeOpaqueFlags"><a href="#computeOpaqueFlags" class="headerlink" title="computeOpaqueFlags()"></a>computeOpaqueFlags()</h4><p>决定一个View是否实心,取决于<code>child.isOpaque</code>,而这个方法实质是调用<code>computeOpaqueFlags()</code>计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> protected void computeOpaqueFlags() &#123;</div><div class="line">    // Opaque if:</div><div class="line">    //   - Has a background</div><div class="line">    //   - Background is opaque</div><div class="line">    //   - Doesn&apos;t have scrollbars or scrollbars overlay</div><div class="line">    //若View包含背景，且背景是不透明的，则打上PFLAG_OPAQUE_BACKGROUND标识</div><div class="line">    if (mBackground != null &amp;&amp; mBackground.getOpacity() == PixelFormat.OPAQUE) &#123;</div><div class="line">        mPrivateFlags |= PFLAG_OPAQUE_BACKGROUND;</div><div class="line">    &#125; else &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_OPAQUE_BACKGROUND;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final int flags = mViewFlags;</div><div class="line">    //若没有横竖滚动条，或者滚动条是OVERLAY类型的，则打上PFLAG_OPAQUE_SCROLLBARS标识</div><div class="line">    if (((flags &amp; SCROLLBARS_VERTICAL) == 0 &amp;&amp; (flags &amp; SCROLLBARS_HORIZONTAL) == 0) ||</div><div class="line">                (flags &amp; SCROLLBARS_STYLE_MASK) == SCROLLBARS_INSIDE_OVERLAY ||</div><div class="line">                (flags &amp; SCROLLBARS_STYLE_MASK) == SCROLLBARS_OUTSIDE_OVERLAY) &#123;</div><div class="line">        mPrivateFlags |= PFLAG_OPAQUE_SCROLLBARS;</div><div class="line">    &#125; else &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_OPAQUE_SCROLLBARS;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ViewGroup 默认情况下(<code>initViewGroup()</code>)会被设置成<code>WILL_NOT_DRAW</code>,会在<code>setFlags()</code>设置了<code>SKIP_DRAW</code>.这样会导致在<code>draw(三个参数)</code>中跳过 <code>draw(canva)</code></li>
<li>ViewGroup 调用了<code>draw(canvas)</code>还不一定执行<code>onDraw(canvas)</code>,因为会判断<code>PFLAG_DIRTY_OPAQUE</code>,<strong>没有设置这个标志位<code>onDraw</code>才会被调用</strong>. 对于这个 FLAG,是在<code>ViewGroup.invalidateChild()</code>中设置的(这个方法被调用的的实质是<strong>我们调用了 View.invalidate()</strong>),他会将他的<strong>父ViewGroup</strong>设置<code>PFLAG_DIRTY_OPAQUE</code>,这样父ViewGroup 在 invalidate 就不会重复绘制一次了.</li>
<li>如果我们想调用 onDraw,可以通过以下方法<ul>
<li>为 ViewGroup 设置背景色</li>
<li>手动 <code>setWillNotDraw(false)</code>，去掉其<code>WILL_NOT_DRAW</code> flag。</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/litefish/article/details/52859300" target="_blank" rel="external">从源码看invalidate和requestLayout的区别</a></li>
<li><a href="https://juejin.im/post/59dae74af265da065755092a" target="_blank" rel="external">你真的了解Android ViewGroup的draw和onDraw的调用时机吗</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/29/Android-非UI线程能更新UI吗/" itemprop="url">
                  Android 非UI线程能更新UI吗
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-29T00:01:57+08:00" content="2018-03-29">
              2018-03-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/29/Android-非UI线程能更新UI吗/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/29/Android-非UI线程能更新UI吗/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/29/Android-非UI线程能更新UI吗/" class="leancloud_visitors" data-flag-title="Android 非UI线程能更新UI吗">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道 Android 非UI线程 不能更新UI,否则会抛异常 <code>CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</code>,我们来了解为什么</p>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><blockquote>
<p>采用一个专门的线程从队列中抽取事件，并把他们转发给应用程序定义的事件处理器</p>
</blockquote>
<p>其实也有人视图多线程的GUI,但是由于竞争条件和死锁导致的稳定性问题等,不得不放弃,否则多线程同时操作GUI会线程同步的问题.</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="更新UI的方法"><a href="#更新UI的方法" class="headerlink" title="更新UI的方法"></a>更新UI的方法</h3><ul>
<li>requestLayout()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-------View.requelayout()-----</div><div class="line">public void requestLayout() &#123;</div><div class="line">    ...</div><div class="line">    if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;</div><div class="line">            mParent.requestLayout();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>View调用requestLayout,会一直调用其父类的<code>ViewParent.requestlayout</code>,而我们的<code>ViewRootImpl</code>就是实现了<code>ViewParent</code>的类,我们在分析 View 绘制流程的时候也分析过 ViewRoot,他是View绘制的开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">-------------ViewRootImpl.requestlayout()---------</div><div class="line"> @Override</div><div class="line">    public void requestLayout() &#123;</div><div class="line">        if (!mHandlingLayoutInLayoutRequest) &#123;</div><div class="line">            checkThread();</div><div class="line">            mLayoutRequested = true;</div><div class="line">            scheduleTraversals();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">-----------------ViewRootImpl.checkThread-----------</div><div class="line">void checkThread() &#123;</div><div class="line">        if (mThread != Thread.currentThread()) &#123;</div><div class="line">            throw new CalledFromWrongThreadException(</div><div class="line">                    &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>终于找到了,原来是<code>ViewRootImpl</code>手动检查了操作线程</p>
<ul>
<li>invalidate()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">-------------View.invalidate()-----------</div><div class="line"></div><div class="line">public void invalidate() &#123;</div><div class="line">        invalidate(true);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"> public void invalidate(boolean invalidateCache) &#123;</div><div class="line">        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,</div><div class="line">            boolean fullInvalidate) &#123;</div><div class="line">    ...   </div><div class="line">    if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class="line">                final Rect damage = ai.mTmpInvalRect;</div><div class="line">                damage.set(l, t, r, b);</div><div class="line">               //重点,一直调用父类的 invalidate p.invalidateChild(this, damage);</div><div class="line">            &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到,View的<code>invalidate</code>也是一直调用其父类VewGroup的<code>invalidateChild()</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">--------------ViewGroup.invalidateChild()-------------</div><div class="line"></div><div class="line"> public final void invalidateChild(View child, final Rect dirty) &#123;</div><div class="line">     ...</div><div class="line">     ViewParent parent = this;</div><div class="line">     ...</div><div class="line">     parent = parent.invalidateChildInParent(location, dirty);</div><div class="line">     ...</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>最终,ViewGroup会调用<code>ViewRootImpl</code>的<code>invalidateChildInParent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123;</div><div class="line">        checkThread();</div><div class="line">        if (DEBUG_DRAW) Log.v(mTag, &quot;Invalidate child: &quot; + dirty);</div><div class="line"></div><div class="line">        if (dirty == null) &#123;</div><div class="line">            invalidate();</div><div class="line">            return null;</div><div class="line">        &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mCurScrollY != 0 || mTranslator != null) &#123;</div><div class="line">            mTempRect.set(dirty);</div><div class="line">            dirty = mTempRect;</div><div class="line">            if (mCurScrollY != 0) &#123;</div><div class="line">                dirty.offset(0, -mCurScrollY);</div><div class="line">            &#125;</div><div class="line">            if (mTranslator != null) &#123;</div><div class="line">                mTranslator.translateRectInAppWindowToScreen(dirty);</div><div class="line">            &#125;</div><div class="line">            if (mAttachInfo.mScalingRequired) &#123;</div><div class="line">                dirty.inset(-1, -1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        invalidateRectOnScreen(dirty);</div><div class="line"></div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到, <code>invalidate()</code>最终方法也是手动调用了<code>checkThread()</code>检查操作UI的线程</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>既然规定 UI线程才能操作 UI 是在 <code>ViewRootImpl</code> 检查的,那么我们只需要在创建<code>ViewRootImpl</code>之前非UI线程修改UI就行了,通过我们上次的文章<code>Activiy Window DecorView的关系</code>得知,<strong>ViewRootImpl是在 onResume()回调后创建的</strong>,所以我们在这之前更新UI是不需要在UI线程的.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/23/Retrofit-源码分析/" itemprop="url">
                  Retrofit 源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-23T23:30:56+08:00" content="2018-03-23">
              2018-03-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/23/Retrofit-源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/23/Retrofit-源码分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/23/Retrofit-源码分析/" class="leancloud_visitors" data-flag-title="Retrofit 源码分析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>创建 API 接口类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface GankApi &#123;</div><div class="line">    String host = &quot;http://gank.io/api/data/&quot;;</div><div class="line">    @GET(&quot;Android/10/&#123;page&#125;&quot;)</div><div class="line">    Call&lt;Android&gt; getAndroid(@Path(&quot;page&quot;) int page);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>创建 Retrofit 实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 创建 Retrofit 实例</div><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">    .baseUrl(GankApi.host)</div><div class="line">    //添加Gson解析</div><div class="line">    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">    .build();</div><div class="line">    </div><div class="line">//生成接口实现类</div><div class="line">GankApi gankApi = retrofit.create(GankApi.class);</div><div class="line"></div><div class="line">//调用接口定义的请求方法,返回请求结果 call</div><div class="line">Call&lt;Android&gt; call = gankApi.getAndroid(1);</div><div class="line"></div><div class="line">//调用 call 对象的 enqueue 方法,执行异步请求</div><div class="line">call.enqueue(Callback callback);</div></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Retrofit-Builder"><a href="#Retrofit-Builder" class="headerlink" title="Retrofit.Builder()"></a>Retrofit.Builder()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//运行平台</div><div class="line">private final Platform platform;</div><div class="line">//callFactory,Http请求,只有一个</div><div class="line">private @Nullable okhttp3.Call.Factory callFactory;</div><div class="line">private HttpUrl baseUrl;</div><div class="line">//一系列结果转换器,将服务器数据(JSON,XML等)转成任意类型,有很多个</div><div class="line">private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();</div><div class="line">//适配器,把请求结果 retrofit2.call&lt;T&gt; 转为 T</div><div class="line">private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();</div><div class="line">//执行的线程池</div><div class="line">private @Nullable Executor callbackExecutor;</div><div class="line"></div><div class="line">public Builder() &#123;</div><div class="line">  this(Platform.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到, Builder() 传入了我们的 Platform</p>
<h4 id="Retrofit-Platform"><a href="#Retrofit-Platform" class="headerlink" title="Retrofit.Platform"></a>Retrofit.Platform</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static class Android extends Platform &#123;</div><div class="line">  @Override public Executor defaultCallbackExecutor() &#123;</div><div class="line">    return new MainThreadExecutor();</div><div class="line">  &#125;</div><div class="line">  @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123;</div><div class="line">    return new ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">  &#125;</div><div class="line">  static class MainThreadExecutor implements Executor &#123;</div><div class="line">    private final Handler handler = new Handler(Looper.getMainLooper());</div><div class="line">    @Override public void execute(Runnable r) &#123;</div><div class="line">      handler.post(r);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在 Android 中,我们的 <code>CallAdapterFactory</code>使用的是<code>ExecutorCallAdapterFactory()</code></li>
<li>在 Android 中,我们的 <code>Executor</code>使用的 <code>MainHandlerr</code>,默认Callback主线程</li>
</ul>
<h3 id="Retrofit-Builder-build"><a href="#Retrofit-Builder-build" class="headerlink" title="Retrofit.Builder().build()"></a>Retrofit.Builder().build()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public Retrofit build() &#123;</div><div class="line">      ...</div><div class="line">      //没有额外配置,默认 OkHttpClient</div><div class="line">      okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">      if (callFactory == null) &#123;</div><div class="line">        callFactory = new OkHttpClient();</div><div class="line">      &#125;</div><div class="line">        //没有额外配置,默认给 defaultCallbackExecutor</div><div class="line">        //而我们前面分析 Platform 得知,返回的是 Android.MainExecutor(MainHandler)</div><div class="line">      Executor callbackExecutor = this.callbackExecutor;</div><div class="line">      if (callbackExecutor == null) &#123;</div><div class="line">        callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      //设置 CallAdapterFactory,由Platform 分析,添加的是 Android.ExecutorCallAdapterFactory</div><div class="line">      List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);</div><div class="line">      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line"></div><div class="line">      //设置 responseConverter</div><div class="line">      List&lt;Converter.Factory&gt; converterFactories =</div><div class="line">          new ArrayList&lt;&gt;(1 + this.converterFactories.size());</div><div class="line"></div><div class="line">      converterFactories.add(new BuiltInConverters());</div><div class="line">      converterFactories.addAll(this.converterFactories);</div><div class="line">      //创建对象</div><div class="line">      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</div><div class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由于我们 <code>Builder()</code>构造函数默认只传入了 Plarform,所以其他参数都是 null, build()方法就会进行一些初始化操作</p>
<ul>
<li><code>CallFactory</code>使用 <code>OkHttpClient</code></li>
<li><code>CallAdapterFactory</code>使用 <code>Android.ExecutorCallAdapterFactory</code></li>
<li><code>Executor</code>使用的是 <code>MainExecutor(MainHandler)</code>,calllback 运行在主线程上</li>
</ul>
<h3 id="动态代理生成对应的API实例"><a href="#动态代理生成对应的API实例" class="headerlink" title="动态代理生成对应的API实例"></a>动态代理生成对应的API实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        new InvocationHandler() &#123;</div><div class="line">            ...</div><div class="line">            //生成对应的请求方法</div><div class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">            //将请求方法封装成 OkHttpCall,方便利用`OkHttp`进行网络请求</div><div class="line">            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            //将封装好的 call 返回,这样我们就能调用对应 API 实例进行同步或者异步请求了</div><div class="line">            return serviceMethod.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>重点就是上面三行代码</p>
<h3 id="ServiceMethod-loadServiceMethod"><a href="#ServiceMethod-loadServiceMethod" class="headerlink" title="ServiceMethod  loadServiceMethod()"></a>ServiceMethod  loadServiceMethod()</h3><blockquote>
<p>ServiceMethod 用于将接口,转为一次 HTTP 调用</p>
</blockquote>
<p>Retrofit 用一个双链表缓存方法<br><code>private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;();</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ServiceMethod loadServiceMethod(Method method) &#123;</div><div class="line">  ServiceMethod result;</div><div class="line">  synchronized (serviceMethodCache) &#123;</div><div class="line">      // 从缓存中获取该方法</div><div class="line">    result = serviceMethodCache.get(method);</div><div class="line">    if (result == null) &#123;</div><div class="line">        // 没有就进行创建并且存入链表缓存</div><div class="line">      result = new ServiceMethod.Builder(this, method).build();</div><div class="line">      serviceMethodCache.put(method, result);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ServiceMethod-Builder-this-method-build"><a href="#ServiceMethod-Builder-this-method-build" class="headerlink" title="ServiceMethod.Builder(this, method).build()"></a>ServiceMethod.Builder(this, method).build()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-----Builder()------</div><div class="line">Builder(Retrofit retrofit, Method method) &#123;</div><div class="line">      this.retrofit = retrofit;</div><div class="line">      this.method = method;</div><div class="line">      this.methodAnnotations = method.getAnnotations();</div><div class="line">      this.parameterTypes = method.getGenericParameterTypes();</div><div class="line">      this.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">初始化了一些参数</div></pre></td></tr></table></figure>
<ul>
<li><code>callFactory</code>,负责创建 HTTP 请求,Http 请求被抽象成了 <code>OKhttp.Call</code>,表示一个可以随时被执行的HTTP请求</li>
<li><code>callAdapter</code>,结果转换器,将<code>retrofit2.Call&lt;T&gt;</code>转为<code>T</code>,这个过程会执行HTTP请求,拿到服务器返回的数据,并且将数据转为<code>T</code>,通过<code>Converter&lt;F,T&gt;</code>实现的</li>
<li><code>responseConverter</code>,<code>Converter&lt;F,T&gt;</code>类型.把服务器数据(JSON.XML,Protoc等)转为<code>T</code></li>
<li><code>parameterHandlers</code>,负责解析API定义的每个方法的参数,采用运行时注解,并且在构造HTTP请求时设置相应参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">------loadServiceMethod()--------</div><div class="line">ServiceMethodCache 实现了缓存</div><div class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</div><div class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</div><div class="line">    if (result != null) return result;</div><div class="line"></div><div class="line">    synchronized (serviceMethodCache) &#123;</div><div class="line">      result = serviceMethodCache.get(method);</div><div class="line">      if (result == null) &#123;</div><div class="line">        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</div><div class="line">        serviceMethodCache.put(method, result);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">  &#125;</div><div class="line">---------------build()------------</div><div class="line">public ServiceMethod build() &#123;</div><div class="line">    //创建 callAdapter</div><div class="line">    callAdapter = createCallAdapter();</div><div class="line">    ...</div><div class="line">    //创建结果转换器</div><div class="line">    responseConverter = createResponseConverter();</div><div class="line">    ...</div><div class="line">    //解析我们的API接口注解,是 @Retention(RUNTIME) 运行时注解</div><div class="line">    for (Annotation annotation : methodAnnotations) &#123;</div><div class="line">        parseMethodAnnotation(annotation);</div><div class="line">      &#125;</div><div class="line">     ...</div><div class="line">     return Call;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="callFactory"><a href="#callFactory" class="headerlink" title="callFactory"></a>callFactory</h4><p>由 Retrofit 提供,我们前面分析过了 CallFactory 的创建 . 我们在构造 Retrofit 对象的时候可以指定 <code>callFactory</code>,(比如 <code>HttpURLConnection</code>,<code>OkHttp</code>),如果不指定,默认设置<code>okHttp.OkHttpClient</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">--------Retrofit 的 builld()方法------</div><div class="line">okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">      if (callFactory == null) &#123;</div><div class="line">        callFactory = new OkHttpClient();</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h4 id="callAdapter"><a href="#callAdapter" class="headerlink" title="callAdapter"></a>callAdapter</h4><p>由 Retrofit 提供,我们前面分析过了 callAdapter的创建,默认 Android 平台是 <code>ExecutorCallAdapterFactory</code>,对应 <code>Executor</code>是<code>MainExecutor(MainLooper)</code>.<code>createCallAdapter</code>最终会调用<code>nextCallAdapter()</code>,遍历所有的 <code>CallAdapter.Factory</code>,拿到自己想要的 callAdapter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">    Executor callbackExecutor = this.callbackExecutor;</div><div class="line">      if (callbackExecutor == null) &#123;</div><div class="line">      //返回 Android.MainThreadExecutor()</div><div class="line">        callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">      &#125;</div><div class="line">      //返回 Android.ExecutorCallAdapterFactory</div><div class="line">      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="responseConverter"><a href="#responseConverter" class="headerlink" title="responseConverter"></a>responseConverter</h4><p>由 Retrofit 提供,逻辑与 <code>callAdapter</code>一致,遍历<code>Converter.Factory</code>,拿到自己想要的 responseConverter,用于将服务器的 <code>Response</code>(也就是 callFactory请求到的<code>Response</code>)转为自己的<code>ResponseBody</code></p>
<h4 id="parameterHandlers"><a href="#parameterHandlers" class="headerlink" title="parameterHandlers"></a>parameterHandlers</h4><p>解析 API 接口的注解类型(比如<code>Path</code>,<code>Query</code>,<code>Field</code>),利用<code>Retrofit.StringConverter</code>将传递的参数转为String,而 <code>@Body</code> 和 <code>@Part</code> 类型的参数则利用 requestBodyConverter 进行转换。</p>
<h3 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h3><blockquote>
<p>利用 serviceMethod 信息,创建对应的 okhttpCall,用于http 请求</p>
</blockquote>
<p>我们使用 <code>execute()</code> 同步或者 <code>enqueue(Callback)</code>异步 进行网络请求.我们直接分析 <code>enqueue(Callback)</code></p>
<h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue()"></a>enqueue()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">    checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line"></div><div class="line">    okhttp3.Call call;</div><div class="line">    Throwable failure;</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line">      ...</div><div class="line">      //创建 Call 对象,后面分析就是 okhttp.call</div><div class="line">      call = rawCall = createRawCall();</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    //进行异步请求,这个 call 是 </div><div class="line">    call.enqueue(new okhttp3.Callback() &#123;</div><div class="line">      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123;</div><div class="line">        Response&lt;T&gt; response;</div><div class="line">        try &#123;</div><div class="line">        //将okhttp.Response 结果转为自己的 Response</div><div class="line">          response = parseResponse(rawResponse);</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">          callFailure(e);</div><div class="line">          return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">        //成功回调</div><div class="line">          callback.onResponse(OkHttpCall.this, response);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      ...</div><div class="line">        //失败的回调</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">       ...</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  --------------createRawCall()--------------</div><div class="line">  </div><div class="line">  private okhttp3.Call createRawCall() throws IOException &#123;</div><div class="line">  //利用 serviceMethod.toCall(args) 创建 okhttp3.Request</div><div class="line">  ///利用到了 parameterHandlers</div><div class="line">  ///函数最后调用了 serviceMethod.callFactory.newCall(request) </div><div class="line">  ///默认是 OkHttpClient</div><div class="line">  okhttp3.Call call = serviceMethod.toCall(args);</div><div class="line">  ...</div><div class="line">  return call;</div><div class="line">&#125;</div><div class="line"></div><div class="line">--------------------parseResponse()------------</div><div class="line"></div><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</div><div class="line">  ResponseBody rawBody = rawResponse.body();</div><div class="line"></div><div class="line">  // Remove the body&apos;s source (the only stateful object) so we can pass the response along.</div><div class="line">  rawResponse = rawResponse.newBuilder()</div><div class="line">      .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</div><div class="line">      .build();</div><div class="line"></div><div class="line">  int code = rawResponse.code();</div><div class="line">  if (code &lt; 200 || code &gt;= 300) &#123;</div><div class="line">    // ...返回错误</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (code == 204 || code == 205) &#123;</div><div class="line">    return Response.success(null, rawResponse);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);</div><div class="line">  try &#123;</div><div class="line">  //转换结果,利用到了我们前面准备好的 responseConverter</div><div class="line">    T body = serviceMethod.toResponse(catchingBody);</div><div class="line">    return Response.success(body, rawResponse);</div><div class="line">  &#125; catch (RuntimeException e) &#123;</div><div class="line">    // ...异常处理</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>这个主要包括三个步骤,具体的</p>
<ul>
<li>创建 <code>OKhttp.call</code><blockquote>
<p>利用 <code>serviceMethod.toCall(args)</code> 创建 okhttp3.Request<br>利用到了 parameterHandlers.<code>toCall</code>函数最后调用了 <code>serviceMethod.callFactory.newCall(request)</code>,默认是 OkHttpClient,也可以指定其他(比如 HtppURLConnection)</p>
</blockquote>
</li>
<li>执行网络请求  (call.execute())</li>
<li>解析网络请求返回的数据  (parseResponse)</li>
</ul>
<h3 id="serviceMethod-adapt-okHttpCall"><a href="#serviceMethod-adapt-okHttpCall" class="headerlink" title="serviceMethod.adapt(okHttpCall)"></a>serviceMethod.adapt(okHttpCall)</h3><p>该方法调用 <code>callAdapter.adapt(okHttpCall)</code>,由前面分析的 <code>Retrofit.Platform</code>我们知道,调用的是 <code>ExecutorCallAdapterFactory</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">-----------------ExecutorCallAdapterFactory.adapt------</div><div class="line">@Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">        return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">-----------------------ExecutorCallbackCall-----------------------</div><div class="line"></div><div class="line">static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</div><div class="line">  final Executor callbackExecutor;</div><div class="line">  final Call&lt;T&gt; delegate;</div><div class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">    this.callbackExecutor = callbackExecutor;</div><div class="line">    this.delegate = delegate;</div><div class="line">  &#125;</div><div class="line">  @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">    if (callback == null) throw new NullPointerException(&quot;callback == null&quot;);</div><div class="line">    delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">      @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">        callbackExecutor.execute(new Runnable() &#123;</div><div class="line">          @Override public void run() &#123;</div><div class="line">            if (delegate.isCanceled()) &#123;</div><div class="line">              callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">            &#125; else &#123;</div><div class="line">              callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">      // 省略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>adapt(call)</code>传入的是<code>okhttp.call</code>,所以 <code>ExecutorCallbackCall.delegete</code>也是 <code>okhttp.call</code>,而<code>callbackExecutor</code>我们在<code>Retrofit.Platform</code>前面分析了,是<code>Handler(MainLooper)</code></p>
<p>这样一来,<strong>我们直接调用了 okhttp.call.enqueue(),在回调方法中, callbackExecutor.execute(new Runnable() {….},利用的是<code>mainHandler.post()</code></strong>,这样就完成了子线程切换到 主线程的工作</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="源码整体流程"><a href="#源码整体流程" class="headerlink" title="源码整体流程"></a>源码整体流程</h4><p><code>GankApi gankApi = retrofit.create(GankApi.class);</code> –&gt;</p>
<p><code>return (T) Proxy.newProxyInstance（...）{...}</code>—-&gt;</p>
<p><code>Call&lt;Android&gt; call = gankApi.getAndroid(1);</code> —-&gt;</p>
<p><code>public Object invoke(...){...} 调用代理类的invoke()。</code></p>
<p>而在代理类中,<code>ServiceMethod</code>创建了对应的API方法,构建HTTP请求需要的参数等信息</p>
<p><code>OkHttpCall</code>利用<code>ServiceMethod</code>创建了对应的<code>okhttp.call</code></p>
<p>最后 <code>ServiceMethod.callAdapter.adapt(okhttpCall)</code>调用对应CalAdapter,然后我们执行<code>enqueue()或者execute()</code>,就是执行<code>okhttpCall</code>对应的方法,完成了HTTP请求.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit</a></li>
<li><a href="http://imxie.itscoder.com/2016/08/20/retrofit-source-learning/" target="_blank" rel="external">框架源码 — 简析学习 Retrofit</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/15/一个Activity从启动到显示内容都发生了什么/" itemprop="url">
                  一个Activity的启动发生了什么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-15T13:47:34+08:00" content="2018-03-15">
              2018-03-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/15/一个Activity从启动到显示内容都发生了什么/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/15/一个Activity从启动到显示内容都发生了什么/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/15/一个Activity从启动到显示内容都发生了什么/" class="leancloud_visitors" data-flag-title="一个Activity的启动发生了什么">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="涉及到的几个类"><a href="#涉及到的几个类" class="headerlink" title="涉及到的几个类"></a>涉及到的几个类</h2><ul>
<li><p><strong>zygote</strong>:开启App新进程,都是通过 <code>zygote的fork</code> 实现的</p>
</li>
<li><p><strong>ActivityManagerService</strong>:管理Activity 的生命周期的服务端</p>
</li>
<li><strong>Instrumentation</strong>: 对Application和Activity 初始化以及生命周期管理的工具类</li>
<li><strong>ActivityThread</strong>:与<code>AMS</code>交互的类,程序入口</li>
<li><strong>ActivityStack</strong>:Activity的栈管理类</li>
<li><strong>ActivityStackSupurvior</strong>:管理<code>ActivityStack</code>的类</li>
</ul>
<h2 id="1-开始请求执行启动Actiivty"><a href="#1-开始请求执行启动Actiivty" class="headerlink" title="1.开始请求执行启动Actiivty"></a>1.开始请求执行启动Actiivty</h2><p>一般来说,我们启动Activity是从<code>Launcher</code>启动的,这个时候还需要通过 <code>Zygote fork</code>一个新进程.我们知道,启动 <code>Activity</code>需要通过<code>Binder</code>机制跨进程来告诉服务端<code>ActivityManagerService</code>启动一个<code>Activity</code></p>
<h3 id="一般来说在Client端有如下步骤"><a href="#一般来说在Client端有如下步骤" class="headerlink" title="一般来说在Client端有如下步骤"></a>一般来说在<code>Client端</code>有如下步骤</h3><ul>
<li><strong>MyActivity</strong>.startActivity()</li>
<li><strong>Activity</strong>.startActivity()</li>
<li><strong>Activity</strong>.startActivityFroResult() <ul>
<li><code>层层调用,最后执行这个方法,如果 requestCode &lt; 0,那么启动 Activity 将不会有 result 返回</code></li>
</ul>
</li>
<li><strong>Instumentation</strong>.execStartActivity<ul>
<li><code>Instrumentation</code>是 Activity 的<code>Client端</code>的实际操作类</li>
</ul>
</li>
<li><strong>ActivityManager</strong>.getService().startActivity()<ul>
<li>getService() : <code>IActivityManager.Stub.asInterface(b)</code></li>
<li><code>ActivityManagerService</code>继承自<code>IActivityManager</code>,getService()会在<code>Client端</code>返回一个 <code>ActivityManagerProxy</code>对象,API26采用了<code>AIDL</code>的方式</li>
</ul>
</li>
</ul>
<blockquote>
<p>到目前为止,Activity 启动流程已经从 <code>Client端</code>转移到了<code>Server端了</code></p>
</blockquote>
<h2 id="2-ActivityManagerService-启动-Activity"><a href="#2-ActivityManagerService-启动-Activity" class="headerlink" title="2.ActivityManagerService 启动 Activity"></a>2.ActivityManagerService 启动 Activity</h2><h3 id="Server-端有如下步骤"><a href="#Server-端有如下步骤" class="headerlink" title="Server 端有如下步骤"></a><code>Server 端</code>有如下步骤</h3><ul>
<li>ActivityManagerService.startActivity()</li>
<li>ActivityManagerService.startActivityAsUser()</li>
<li><code>ActivityStarter</code>.startActivityMayWait()</li>
<li><code>ActivityStarter</code>.startActivityLocked()</li>
<li><code>ActivityStarter</code>.startActivity(),函数结尾调用-&gt; </li>
<li><code>ActivityStarter</code>.startActivity()</li>
<li><code>ActivityStarter</code>.startActivityUnchecked()</li>
<li><code>ActivityStackSupervisor</code>.resumeFocusedStackTopActivityLocked()</li>
<li><code>ActivityStack</code>.resumeTopActivityUncheckedLocked()</li>
<li><p><code>ActivityStack</code>.resumeTopActivityInnerLocked()</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    if (mResumedActivity != null) &#123;</div><div class="line">        if (DEBUG_STATES) Slog.d(TAG_STATES,</div><div class="line">                &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</div><div class="line">        pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);</div><div class="line">    &#125;        ...</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>经过一系列调用,最终调用了 <code>startPausingLocked()</code>,该方法作用就是让系统栈的Activity执行 <code>onPause</code></p>
</blockquote>
<h2 id="3-栈顶-Activity-的-onPause-方法"><a href="#3-栈顶-Activity-的-onPause-方法" class="headerlink" title="3.栈顶 Activity 的 onPause 方法"></a>3.栈顶 Activity 的 onPause 方法</h2><h3 id="启动新-Activity-之前栈顶的-Activity-onPause-主要下面几个步骤"><a href="#启动新-Activity-之前栈顶的-Activity-onPause-主要下面几个步骤" class="headerlink" title="启动新 Activity ,之前栈顶的 Activity onPause 主要下面几个步骤"></a>启动新 Activity ,之前栈顶的 Activity onPause 主要下面几个步骤</h3><ul>
<li><code>ActivityStack</code>.startPausingLocked()</li>
<li><code>ApplicationThread</code>.schedulePauseActivity()</li>
<li><code>ActivityThread.H</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.handleMessage()</li>
<li><code>ActivityThread</code>.handlePauseActivity()<ul>
<li>这个方法会让 栈顶Activity 先 <code>onPuase</code>,然后启动<code>新Activity</code></li>
<li><code>ActivityThread</code>.performPauseActivity()</li>
<li><code>ActivityThread</code>.performPauseActivityIfNeeded()</li>
<li><code>Instrumentation</code>.callActivityOnPause()</li>
<li><code>Activity</code>.performPause()</li>
<li><code>Activity</code>.onPause()</li>
</ul>
</li>
</ul>
<blockquote>
<p>在这一步,栈顶的 Activity 已经执行了 <code>onPause</code> 方法,此时返回  (3) 步骤 的 <code>handlePauseActivity()</code> ,方法最后执行了 <code>ActivityManager.getService().activityPaused(token);</code> 来告诉 AMS “栈顶Activity 已经” <strong>onPuase()</strong> 了, Binder 跨进程调用</p>
</blockquote>
<ul>
<li><code>ActivityManager</code>.getService().activityPaused(token);</li>
<li><code>ActivityStack</code>.activityPausedLocked()</li>
<li><code>ActivityStack</code>.completePauseLocked()</li>
<li><code>ActivityStackSupervisor</code>.resumeFocusedStackTopActivityLocked()</li>
<li><code>ActivityStack</code>.resumeTopActivityUncheckedLocked()</li>
<li><code>ActivityStack</code>.resumeTopActivityInnerLocked(),<code>这个方法前面部分代码在前面会执行 startPausingLocked(),让栈顶activity onPause,前面 (2) 分析过</code></li>
<li><code>ActivityStackSupervisor</code>.startSpecificActivityLocked()</li>
</ul>
<blockquote>
<p><code>startSpecificActivityLocked</code> 会判断启动的 Activity 所属进程是否已经启动,启动的话直接调用 <code>realStartActivityLocked</code>.  否则调用 <code>startProcessLocked()</code>,启动应用进程</p>
</blockquote>
<h2 id="4-启动Activity所属的应用进程"><a href="#4-启动Activity所属的应用进程" class="headerlink" title="4.启动Activity所属的应用进程"></a>4.启动Activity所属的应用进程</h2><p>前面分析了,如果Activity进程没有启动,会调用<code>startProcessLocked()</code>启动进程.</p>
<h4 id="有如下步骤"><a href="#有如下步骤" class="headerlink" title="有如下步骤"></a>有如下步骤</h4><ul>
<li><code>ActivityManagerService</code>.startPorcess()</li>
<li><code>ActivityManagerService</code>.startProcessLocked()</li>
<li><code>Process</code>.start()</li>
<li><code>ZygoteProcess</code>.start()</li>
<li><code>ZygoteProcess</code>.startViaZygote()</li>
<li><code>ActivityThread</code>.main()</li>
<li><code>ActivityThread</code>.attach()</li>
<li><code>ActivityManagerService</code>.attachApplicationLocked()</li>
<li><code>ActivityStackSupervisor</code>.attachApplicationLocked()</li>
<li><code>ActivityStackSupervisor</code>.realStartActivityLocked</li>
</ul>
<p>涉及 <code>zygote</code>启动进程的源码暂时不分析了,我们只需要知道 <code>Zygote</code>通过<code>Socket</code>方式让<code>Zygote fork</code>出一个新进程,然后根据<code>android.app.ActivityThread</code>字符串,反射出<code>ActivityThread</code>对象并且调用<code>main()</code>方法,这样我们的进程已经启动了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    ...</div><div class="line">    Looper.prepareMainLooper();</div><div class="line"></div><div class="line">    ActivityThread thread = new ActivityThread();</div><div class="line">    thread.attach(false);</div><div class="line">    ...</div><div class="line">    Looper.loop();</div><div class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到, <code>ActivityThread 的 main</code> 方法初始化并且启动了一个 <code>loop</code>,并且执行了自己的 <code>attch</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private void attach(boolean system) &#123;</div><div class="line">    ...</div><div class="line">    final IActivityManager mgr = ActivityManager.getService();</div><div class="line">    try &#123;</div><div class="line">        mgr.attachApplication(mAppThread);</div><div class="line">    &#125; catch (RemoteException ex) &#123;</div><div class="line">        throw ex.rethrowFromSystemServer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法通过<code>Binder</code>调用了<code>ActivityManagerService</code>的<code>attachApplication</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</div><div class="line">            int pid) &#123;</div><div class="line">    ...</div><div class="line">    if (normalMode) &#123;</div><div class="line">        try &#123;</div><div class="line">            if (mStackSupervisor.attachApplicationLocked(app)) &#123;</div><div class="line">                didSomething = true;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>attachApplicationLocked(app)</code>中,启动了应用进程.调用了<code>realStartActivityLocked()</code>,开始 Activity 的启动.</p>
<h2 id="5-启动-Activity"><a href="#5-启动-Activity" class="headerlink" title="5.启动 Activity"></a>5.启动 Activity</h2><h3 id="从启动了对应-应用进程-到启动-Activity-主要包括以下几个步骤"><a href="#从启动了对应-应用进程-到启动-Activity-主要包括以下几个步骤" class="headerlink" title="从启动了对应 应用进程,到启动 Activity,主要包括以下几个步骤"></a>从启动了对应 应用进程,到启动 Activity,主要包括以下几个步骤</h3><ul>
<li><code>ActivityStackSupervisor</code>.attachApplicationLocked()</li>
<li><code>ActivityStackSupervisor</code>.realStartActivityLocked()</li>
<li><code>ApplicationThread</code>.scheduleLaunchActivity()</li>
<li><code>ActivityThread</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.handleMessage()</li>
<li><code>ActivityThread</code>.handleLauncherActivity()</li>
<li><code>ActivityThread</code>.performLauncherActivity(),这个方法比较重要</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"> private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line">    //从 ActivityClientRecord 获取 Activity的组件信息</div><div class="line">    ActivityInfo aInfo = r.activityInfo;</div><div class="line">    if (r.packageInfo == null) &#123;</div><div class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</div><div class="line">                Context.CONTEXT_INCLUDE_CODE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ComponentName component = r.intent.getComponent();</div><div class="line">    if (component == null) &#123;</div><div class="line">        component = r.intent.resolveActivity(</div><div class="line">            mInitialApplication.getPackageManager());</div><div class="line">        r.intent.setComponent(component);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //通过 Instrumentation 的 newActivity </div><div class="line">    //使用类加载器 反射 创建 Activity 对象</div><div class="line">    if (r.activityInfo.targetActivity != null) &#123;</div><div class="line">        component = new ComponentName(r.activityInfo.packageName,</div><div class="line">                r.activityInfo.targetActivity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ContextImpl appContext = createBaseContextForActivity(r);</div><div class="line">    Activity activity = null;</div><div class="line">    try &#123;</div><div class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</div><div class="line">        activity = mInstrumentation.newActivity(</div><div class="line">                cl, component.getClassName(), r.intent);</div><div class="line">       &#125;</div><div class="line">    ...</div><div class="line">    //通过 LoadedApk 的 makeApplication 创建 Application 对象</div><div class="line">    //也是通过反射创建的对象, makeApplication 内部创建完对象后,会调用 application.attach() 方法</div><div class="line">    //在 makeApplication 中,通过 Instrumentation 的 callApplicationOnCreate </div><div class="line">    //来调用 application 的 onCreate() 方法</div><div class="line">    try &#123;</div><div class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</div><div class="line"></div><div class="line">        if (activity != null) &#123;</div><div class="line">           ...</div><div class="line">           //调用 activity 的 attach() 方法</div><div class="line">           //在 attach 方法中,ContextImpl会与Activity 建立联系</div><div class="line">           //attch 方法中,也会初始化Windows,将自己与Window建立联系</div><div class="line">           //这个方法与Activity的显示相关，我们在以后的文章中分析Activity是怎样显示的</div><div class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</div><div class="line">            ...</div><div class="line">            //调用 callActivityOnCreate,最终调用了 onCreate</div><div class="line">            if (r.isPersistable()) &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">            &#125; else &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">            if (!r.activity.mFinished) &#123;</div><div class="line">            //调用 performStart,最终是调用 onStart</div><div class="line">                activity.performStart();</div><div class="line">                r.stopped = false;</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">            //根据情况调用 onRestoreInstance</div><div class="line">            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</div><div class="line">            ...</div><div class="line">    return activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Instrumentation</code>.callActivityOnCreate()</li>
<li><code>Activity</code>.onCreate()</li>
<li><code>Activity</code>.performStart()</li>
<li><code>Activity</code>.onStart()</li>
<li><code>Instrumentation</code>.callActivityOnStart()</li>
<li><code>Activity</code>.onStart()<ul>
<li>如果需要的话</li>
<li><code>Instrumentation</code>.callActivityOnRestoreInstanceState()</li>
<li><code>Activity</code>.performRestoreInstanceState()</li>
<li><code>Activity</code>.onRestoreInstanceState()<blockquote>
<p>可以看到 onRestoreInstance 在 onStart()后 紧接着执行</p>
</blockquote>
</li>
</ul>
</li>
<li>回到:<code>ActivityThread</code>.performLauncherActivity() -&gt; 继续执行<code>ActivityThread</code>.handleResumeActivity()</li>
<li><code>ActivityThread</code>.performResumeActivity()</li>
<li><code>Activity</code>.performResume()</li>
<li><code>Instrumentation</code>.callActivityOnResume()</li>
<li><code>Activity</code>.onResume()</li>
<li>回到: <code>ActivityThread</code>.handleResumeActivity(),继续执行 <code>ActivityManager</code>.getService().activityResumed(token);</li>
</ul>
<blockquote>
<p>到这一步,利用<code>Binder</code>通知<code>ActivityManagerService</code>当前 Activity 已经<code>onResume()</code>了,接下来要做的就是之前栈顶的Activity <code>onStop</code></p>
</blockquote>
<h2 id="6-之前栈顶Activity的onStop"><a href="#6-之前栈顶Activity的onStop" class="headerlink" title="6.之前栈顶Activity的onStop"></a>6.之前栈顶Activity的onStop</h2><h3 id="之前的栈顶Activity执行-onStop-主要有下面几个步骤"><a href="#之前的栈顶Activity执行-onStop-主要有下面几个步骤" class="headerlink" title="之前的栈顶Activity执行 onStop 主要有下面几个步骤"></a>之前的栈顶Activity执行 onStop 主要有下面几个步骤</h3><ul>
<li>回到 (5) 的<code>ActivityThread</code>.handleResumeActivity(),方法尾部调用</li>
<li><code>Looper.myQueue().addIdleHandler(new Idler())</code>;</li>
<li>在 <code>Idler</code>方法内部,执行了 <code>ActivityManager</code>.getService().activityIdle()</li>
<li><code>ActivityStackSupervisor</code>.activityIdleInternalLocked() </li>
<li><code>ActivityStack</code>.stopActivityLocked()</li>
<li><code>ApplicationThread</code>.scheduleStopActivity()</li>
<li><code>ActivityThread</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.handleMessage()</li>
<li><code>ActivityThread</code>.handleStopActivity()</li>
<li><code>ActivityThread</code>.performStopActivityInner()<ul>
<li><code>ActivityThread</code>.callCallActivityOnSaveInstanceState()</li>
<li><code>Instrumentation</code>.callActivityOnSaveInstanceState()</li>
<li><code>Activity</code>.performSaveInstanceState()</li>
<li><code>Activity</code>.onSaveInstanceState(): 这个方法就是系统销毁时,还原状态数据的方法<blockquote>
<p>可以看到 onSaveInstance 在 onStop 执行前调用</p>
</blockquote>
</li>
</ul>
</li>
<li>回到: <code>ActivityThread</code>.performStopActivityInner() -&gt; 执行了<code>Activity</code>.performStop()</li>
<li><code>Instrumentation</code>.callActivityOnStop()</li>
<li><code>Activity</code>.onStop()</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Activity 启动最后都是通过<code>startActivityForResult()</code>来的.</li>
<li><code>ActivityThread</code> 向 <code>AMS</code> 传消息通过<strong>ActivityManager</strong>.getService().startActivity(),他返回一个 <code>BinderProxy</code>.  而<code>AMS</code>向<code>ActivityThread</code>传递消息通过<code>ApplicationThread</code></li>
<li><code>AMS</code>启动Activity前会先将当前系统栈顶<code>Activity</code>执行<code>onPause</code></li>
<li><code>onPause</code>执行完后,会告诉<code>AMS</code>栈顶<code>Activity</code>已经 <code>onPause</code>了,这个时候<code>AMS</code>会执行启动<code>Activity</code>逻辑,首先会判断是否Activity所属应用进程已经创建启动了,没有的话先<code>Zygote</code>fork出一个应用进程,反射创建出<code>ActivityThread</code>对象,然后执行<code>ActivityThread</code>的main 方法</li>
<li>有了应用进程后,在<code>performLaunchActivity()</code>中,会通过反射创建<code>Activity</code>对象以及<code>Application</code>对象,然后执行<code>Application.attach()-&gt;onCreate()</code>,然后执行<code>Activity.attach()</code></li>
<li>然后Activity在<code>handleLaunchActivity</code>会执行<code>performLaunchActivity()</code>依次执行<code>onCreate(),onStart()</code>,需要的话会紧接着执行<code>onRestoreInstance()</code></li>
<li>返回<code>handleLaunchActivity()</code>方法,会执行<code>handleResumeActivity()</code>调用Activity的<code>onResume()</code></li>
<li>执行完<code>onResume()</code>后,<code>ActivityThread</code>告诉<code>AMS</code>当前Activity已经<code>onResume</code>了,接下来执行之前栈顶Activity的<code>onStop()</code></li>
<li><code>ActivityThread</code>执行对应的<code>onStop()</code>,在<code>onStop</code>调用前会先调用<code>onSaveInstacne()</code></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/11/Window、Activity、DecorView之间的联系以及View的绘制流程/" itemprop="url">
                  Activity的显示过程以及Window、Activity、DecorView之间的联系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-02-11T17:03:12+08:00" content="2018-02-11">
              2018-02-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/02/11/Window、Activity、DecorView之间的联系以及View的绘制流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/11/Window、Activity、DecorView之间的联系以及View的绘制流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/02/11/Window、Activity、DecorView之间的联系以及View的绘制流程/" class="leancloud_visitors" data-flag-title="Activity的显示过程以及Window、Activity、DecorView之间的联系">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p><code>Activity</code> 只控制生命周期和处理事件.真正的视图容器是 <code>Window</code>.<strong>Activity像一个管理控制器,管理window来添加与显示View,以及通过其他回调方法,来与 Window 和 View 进行交互</strong></p>
<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p><code>View</code> 的容器,内部持有一个 <code>DecorView</code>,<code>DecorView</code>是View 的根布局.Window 是抽象类,具体实现类是<code>PhoneWindow</code>,<code>PhoneWindow</code>内部有<code>DecorView</code>,通过<code>DecorView</code>来加载<code>Activity</code>设置的布局<code>R.layout.activity_main</code>.<strong><code>Window</code>通过<code>WindowManager</code>将<code>DecorView</code>加载到<code>Window</code>里面,并且将<code>DecorView</code>交给<code>ViewRoot</code>,进行时图绘制和其他交互.</strong></p>
<h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p>Activity 的根节点,我们平时<code>setContentView</code>就是将需要加载的布局添加到 DecorView的<code>Id 叫 content 的子View中了(这个View本质是 FrameLayout).</code></p>
<h2 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h2><p><strong>ViewRoot 对应实现类 ViewRootImpl,他是连接WindowManagerService 和 DecorView 的纽带,所有View的绘制以及事件分发都通过它来执行的</strong></p>
<h3 id="四者关系图"><a href="#四者关系图" class="headerlink" title="四者关系图"></a>四者关系图</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-e773ab2cb83ad214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h2><p>继承自 <code>ViewManager</code>,表示有添加删除 View 的能力</p>
<h2 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h2><p><code>WindowManager</code>实现类,实质是<code>WindowManagerGlobal</code>的代理类</p>
<h2 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h2><p>与 <code>WMS</code> 通讯的类,维护了三个集合:所有<code>DecorView</code>,所有布局参数<code>LayoutParams</code>以及<code>ViewRootImpl</code></p>
<h2 id="WindowSession"><a href="#WindowSession" class="headerlink" title="WindowSession"></a>WindowSession</h2><p>ViewRootImpl与WMS的对话通讯类</p>
<h2 id="DecorView-如何创建的"><a href="#DecorView-如何创建的" class="headerlink" title="DecorView 如何创建的"></a>DecorView 如何创建的</h2><h3 id="setContent"><a href="#setContent" class="headerlink" title="setContent"></a>setContent</h3><p>我们加载布局都是从 Activity 的 <code>setContent</code>开始的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</div><div class="line">    getWindow().setContentView(layoutResID);</div><div class="line">    initWindowDecorActionBar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getWindow()对应于 <code>PhoneWindow</code>,我们看一下 <code>Activity</code> 是如何获得<code>Window</code>对象的,Activity 启动时会调用<code>attach()</code>方法,在这里面初始化了<code>PhoneWindow</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">final void attach(Context context, ActivityThread aThread,</div><div class="line">    Instrumentation instr, IBinder token, int ident,</div><div class="line">    Application application, Intent intent, ActivityInfo info,</div><div class="line">    CharSequence title, Activity parent, String id,</div><div class="line">    NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">    Configuration config, String referrer, IVoiceInteractor voiceInteractor,</div><div class="line">    Window window) &#123;</div><div class="line">        ....</div><div class="line">        mWindow = new PhoneWindow(this, window);//创建一个Window对象</div><div class="line">        mWindow.setWindowControllerCallback(this);</div><div class="line">        mWindow.setCallback(this);//设置回调，向Activity分发点击或状态改变等事件</div><div class="line">        mWindow.setOnWindowDismissedCallback(this);</div><div class="line">        //这就是传说中的UI线程，也就是ActivityThread所在的，</div><div class="line">        mUiThread = Thread.currentThread();</div><div class="line">        ....</div><div class="line">        mWindow.setWindowManager(</div><div class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</div><div class="line">            mToken, mComponent.flattenToString(),</div><div class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);//给Window设置WindowManager对象</div><div class="line">        ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Activity</code> 的 <code>attach</code>方法中,生成了<code>PhoneWindow</code>对象.有了<code>Window</code>对象,.我们就可以将<code>DecorView</code>添加到<code>Window</code>对象.另外初始化了 <code>mUiThread</code>,继续看<code>PhoneWindow</code>的<code>setContentView</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    if (mContentParent == null) &#123;//mContentParent为空，创建一个DecroView</div><div class="line">        installDecor();</div><div class="line">    &#125; else &#123;</div><div class="line">        mContentParent.removeAllViews();//mContentParent不为空，删除其中的View</div><div class="line">    &#125;</div><div class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);//为mContentParent添加子View,即Activity中设置的布局文件</div><div class="line">    final Callback cb = getCallback();</div><div class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">        cb.onContentChanged();//回调通知，内容改变</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>mContentParent</code>就是 contentView 对应的FrameLayout</p>
<p>通过上面流程我们大概可以知道, <code>Activity</code>当<code>attach</code>时就会创建一个 <code>PhoneWindow</code>,而我们的<code>DecorView</code>根视图添加到<code>PhoneWindow</code>的关键时候就是我们的<code>setContentView()</code>方法执行的时候.到这个时候,视图一层一层嵌套上了.</p>
<h3 id="installDecor"><a href="#installDecor" class="headerlink" title="installDecor()"></a>installDecor()</h3><p>在前面的 <code>setContentView</code>方法中,有初始化 <code>DecorView</code>的操作,我们看看怎样创建<code>DecorView</code>并且设置整体布局的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private void installDecor() &#123;</div><div class="line">    if (mDecor == null) &#123;</div><div class="line">         //生成DecorView</div><div class="line">        mDecor = generateDecor();</div><div class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</div><div class="line">        mDecor.setIsRootNamespace(true);</div><div class="line">        if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123;</div><div class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        // 为DecorView设置布局格式，并返回mContentParent</div><div class="line">        mContentParent = generateLayout(mDecor); </div><div class="line">        ...</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="generateDecor"><a href="#generateDecor" class="headerlink" title="generateDecor()"></a>generateDecor()</h3><p>该方法很简单,就是new出了 <code>DecorView</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected DecorView generateDecor() &#123;</div><div class="line">    return new DecorView(getContext(), -1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="generateLayout"><a href="#generateLayout" class="headerlink" title="generateLayout()"></a>generateLayout()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</div><div class="line">    // 从主题文件中获取样式信息</div><div class="line">    TypedArray a = getWindowStyle();</div><div class="line"></div><div class="line">    ...................</div><div class="line">    //设置有无标题栏等一些操作</div><div class="line"></div><div class="line">    ................</div><div class="line"></div><div class="line">    // 根据主题样式，加载窗口布局,一堆 if else 找到布局文件</div><div class="line">    int layoutResource;</div><div class="line">    int features = getLocalFeatures();</div><div class="line">    // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</div><div class="line">    if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123;</div><div class="line">        layoutResource = R.layout.screen_swipe_dismiss;</div><div class="line">    &#125; else if(...)&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //加载主题对应的layoutResource</div><div class="line">    View in = mLayoutInflater.inflate(layoutResource, null);</div><div class="line"></div><div class="line">    //往DecorView中添加主题对应加载的View,到这里DecorView有了布局,而布局里面对应有 `id:content`,所以 contentView 与 DecorView 关联上了</div><div class="line">    decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); </div><div class="line">    mContentRoot = (ViewGroup) in;</div><div class="line">    //获得 `id:content` 对应的 View,这里获取的就是mContentParent</div><div class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    return contentParent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>整体逻辑还是很清晰的</strong></p>
<p><strong>首先从主题获取样式,通过<code>addView</code>加载对应布局到 DecorView,然后根据 <code>id:content</code>获取到 mContentParent.最后我们通过 setContentView 将自己的布局<code>inflate</code> 到 <code>mContentParent</code>中</strong></p>
<blockquote>
<p>注意,这个时候还没有将 DecorView 添加到<code>PhoneWindow</code>中!所以没有显示任何东西</p>
</blockquote>
<h2 id="DecorView-的显示"><a href="#DecorView-的显示" class="headerlink" title="DecorView 的显示"></a>DecorView 的显示</h2><h3 id="为什么-onResume-后才对用户可见呢"><a href="#为什么-onResume-后才对用户可见呢" class="headerlink" title="为什么 onResume()后才对用户可见呢?"></a>为什么 <code>onResume()</code>后才对用户可见呢?</h3><p>这里需要从 <code>ActivityThread</code> 说起,我们启动一个 <code>Activity</code>,会执行到 <code>ActivityThread</code> 的<code>handleLaunchActivity()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line"></div><div class="line">    //就是在这里调用了Activity.attach()，初始化了 PhoneWindow.</div><div class="line">    //接着调用了Activity.onCreate()和Activity.onStart()生命周期，</div><div class="line">    //但是由于只是初始化了mDecor，添加了布局文件，还没有把</div><div class="line">    //mDecor添加到负责UI显示的PhoneWindow中，所以这时候对用户来说，是不可见的</div><div class="line">    Activity a = performLaunchActivity(r, customIntent);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    if (a != null) &#123;</div><div class="line">    //这里面执行了Activity.onResume()</div><div class="line">    handleResumeActivity(r.token, false, r.isForward,</div><div class="line">                        !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</div><div class="line"></div><div class="line">    if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</div><div class="line">        try &#123;</div><div class="line">                r.activity.mCalled = false;</div><div class="line">                //执行Activity.onPause()</div><div class="line">                mInstrumentation.callActivityOnPause(r.activity);</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点看 <code>handleResumeActivity</code>,DecorView 和 <code>ViewRoot</code>将会出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">final void handleResumeActivity(IBinder token, boolean clearHide, </div><div class="line">                                boolean isForward, boolean reallyResume) &#123;</div><div class="line"></div><div class="line">    //这个时候，Activity.onResume()已经调用了，但是现在界面还是不可见的,因为 DecorView 没有添加到 Window 中</div><div class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class="line"></div><div class="line">    if (r != null) &#123;</div><div class="line">        final Activity a = r.activity;</div><div class="line">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</div><div class="line">        //获取 phoneWindows</div><div class="line">            r.window = r.activity.getWindow();</div><div class="line">            //获取 DecorView</div><div class="line">            View decor = r.window.getDecorView();</div><div class="line">            //decor对用户不可见</div><div class="line">            decor.setVisibility(View.INVISIBLE);</div><div class="line">            ViewManager wm = a.getWindowManager();</div><div class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</div><div class="line">            a.mDecor = decor;</div><div class="line"></div><div class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</div><div class="line"></div><div class="line">            if (a.mVisibleFromClient) &#123;</div><div class="line">                a.mWindowAdded = true;</div><div class="line">                //如果可见,那么就添加到 WindowManager中</div><div class="line">                wm.addView(decor, l);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!r.activity.mFinished &amp;&amp; willBeVisible</div><div class="line">                    &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</div><div class="line">                //在这里，执行了重要的操作,使得DecorView可见</div><div class="line">                if (r.activity.mVisibleFromClient) &#123;</div><div class="line">                    r.activity.makeVisible();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 <code>makeVisible</code>,才将界面设置为可见了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void makeVisible() &#123;</div><div class="line">   if (!mWindowAdded) &#123;</div><div class="line">        ViewManager wm = getWindowManager();</div><div class="line">        wm.addView(mDecor, getWindow().getAttributes());//将DecorView添加到WindowManager</div><div class="line">        mWindowAdded = true;</div><div class="line">    &#125;</div><div class="line">    mDecor.setVisibility(View.VISIBLE);//DecorView可见</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>到了这里DecorView才可见,显示在屏幕中</strong>, 其关键作用的是<code>wm.addView(mDecor, getWindow().getAttributes())</code>,因为它的内部创建了 <code>ViewRootImpl</code>,负责绘制各个子View</p>
<p><code>WindowManager</code>继承自<code>ViewManager</code>,他是一个接口.<code>WindowManager具体实现类是 WindowManagerImpl</code>,我们看看他的<code>addView()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public final class WindowManagerImpl implements WindowManager &#123;    </div><div class="line">    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public void addView(View view, ViewGroup.LayoutParams params) &#123;</div><div class="line">        //调用 WindowManagerGlobal 的方法</div><div class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">----------------------WindowManagerGlobal-------</div><div class="line"></div><div class="line">public void addView(View view, ViewGroup.LayoutParams params,</div><div class="line">                    Display display, Window parentWindow) &#123;</div><div class="line"></div><div class="line">    ......</div><div class="line">    synchronized (mLock) &#123;</div><div class="line"></div><div class="line">        ViewRootImpl root;</div><div class="line">        //实例化一个ViewRootImpl对象</div><div class="line">        root = new ViewRootImpl(view.getContext(), display);</div><div class="line">        view.setLayoutParams(wparams);</div><div class="line"></div><div class="line">        mViews.add(view);</div><div class="line">        mRoots.add(root);</div><div class="line">        mParams.add(wparams);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    try &#123;</div><div class="line">        //将DecorView交给ViewRootImpl</div><div class="line">        root.setView(view, wparams, panelParentView);</div><div class="line">    &#125; catch (RuntimeException e) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WindowManagerGlobal 维护了三个集合(添加进来的<code>DecorView</code>,布局参数<code>LayoutParams</code>,和刚才实例化的 <code>ViewRootImpl</code>)</p>
<p><strong>ViewRootImpl的setView()中,调用了 requestLayout() 方法,他经过一系列方法调用(scheduleTraversals() -&gt; doTravelsal() -&gt; performTravelsals()),最终调用了<code>performTraversals()</code>方法,然后绘制流程层层调用,完成绘制,最终界面显示出来了.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</div><div class="line">    ...</div><div class="line">    requestLayout();</div><div class="line">    ...</div><div class="line">    //利用 WindowSession,最终将 ViewRootImpl 与 WindowManagerService 联系起来</div><div class="line">    //将 mWindow 传递给了 WMS,mWindow是内部 `W` 类,他持有 ViewRtootImpl 对象,这样WMS就可以让 ViewRootImpl 做一些事了,主动添加 View 到 Window 中</div><div class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</div><div class="line">        getHostVisibility(), mDisplay.getDisplayId(),</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">-----------requestLayout------</div><div class="line"></div><div class="line">public void requestLayout() &#123;</div><div class="line">        if (!mHandlingLayoutInLayoutRequest) &#123;</div><div class="line">        //检查 UI 操作是否在 UI线程里</div><div class="line">            checkThread();</div><div class="line">            mLayoutRequested = true;</div><div class="line">            //继续调用</div><div class="line">            scheduleTraversals();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">-----------scheduleTraversals-----------</div><div class="line"></div><div class="line">void scheduleTraversals() &#123;</div><div class="line">        ...</div><div class="line">        //发送消息到 Handler 中</div><div class="line">        mChoreographer.postCallback(</div><div class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">在 TraversalRunnable 的 run()方法中</div><div class="line"></div><div class="line">public void run() &#123;</div><div class="line">            doTraversal();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">------------- doTraversal---------</div><div class="line"></div><div class="line">void doTraversal() &#123;</div><div class="line">        ...</div><div class="line">        performTraversals();</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>而对于 Window 添加 <code>DecorView</code>的过程,是通过<code>WindowSession</code>完成的.</strong></p>
<p><strong><code>WindowSession</code>内部会通过 <code>WindowsManagerService的 addToDisplay(mWindow)</code>,让 Session 持有 <code>W</code>类,W类内部持有<code>ViewRootImpl</code>,而<code>ViewRootImpl</code>又持有<code>DecorView</code>,这样WMS可以利用持有的 Session 引用主动添加 DecorView 到Window上</strong></p>
<p><strong>ViewRootImpl 负责管理View树,和通过<code>WindowSession</code>与<code>WMS</code>进行交互,ViewRootImpl也负责UI布局的渲染和一部分事件分发给Activity</strong></p>
<h3 id="为什么-onResume-才能拿到具体的View宽高呢"><a href="#为什么-onResume-才能拿到具体的View宽高呢" class="headerlink" title="为什么 onResume() 才能拿到具体的View宽高呢?"></a>为什么 <code>onResume()</code> 才能拿到具体的View宽高呢?</h3><blockquote>
<p>通过上面分析,我们知道只有在 <code>onResume()</code>后,<code>ViewRootImpl</code>才会开始 <code>performTravelsals</code>进行View层层绘制.绘制完才能拿到具体值.所以也只有在 <code>onResume()</code>后,才能拿到具体View宽高</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Window</code>是虚拟的概念,他是View的容器,具体的对于每个Activity,都有一个 <code>PhoneWindow</code>,里面存储了 <code>DecorView</code>,我们<code>setContentView</code>都是将布局实例化出来添加到<code>DecorView</code>的<code>id:content</code>中了</li>
<li><code>WindowManagerImpl</code>是<code>WindowManager</code>的实现类,他代理了<code>WindowManagerGlobal</code>.</li>
<li><code>WindowManagerGlobal</code>全局只有一个,它保存了App所有的<code>DecorView</code>,所有的<code>contentView</code>以及布局参数<code>LayoutParams</code>.</li>
<li><code>ViewRootImpl</code>都持有<code>WindowSession</code>(WindowSession只有一个),他可以与<code>WindowManagerService</code>通讯.而<code>WMS</code>持有<code>ViewRootImpl::W</code>,<code>W</code>持有了<code>ViewRootImpl</code>也可以向<code>ViewRootImpl</code>通讯</li>
<li>ViewRootImpl 每个Activity都有一个,它负责管理View树,和通过<code>WindowSession</code>与<code>WMS</code>进行交互,ViewRootImpl也负责UI布局的渲染和一部分事件分发给Activity</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/03/View-绘制流程/" itemprop="url">
                  View 绘制流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-02-03T15:48:24+08:00" content="2018-02-03">
              2018-02-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/02/03/View-绘制流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/03/View-绘制流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/02/03/View-绘制流程/" class="leancloud_visitors" data-flag-title="View 绘制流程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>View</code> 的绘制从 <code>ViewRoot</code> 的 <code>performTraversals</code> 方法开始，他经过 <code>measure，layout，draw</code> 三个过程才能将一个 View 绘制出</p>
<ul>
<li><p>对于 draw ,是 <code>performDraw()</code> 以后,他是调用 <code>draw(boolean)</code>,然后调用<code>ThreadedRender.draw(三个参数) -&gt; ThreadedRender.updateRootDisplayList() -&gt; ThreadedRender.updateViewTreeDisplayList() -&gt; View.updateDisplayListIfDirty()</code></p>
</li>
<li><p>在最后的<code>View.updateDisplayListIfDirty()</code>里,才会根据一些标志位(<code>PFLAG_DRAWING_CACHE_VALID , PFLAG_SKIP_DRAW</code>)来判断到底是直接执行我们的 <strong>View.draw(canvas)</strong> 绘制自身还是 <strong>View.dispatchDraw()</strong> 不绘制自身,直接分发事件</p>
</li>
</ul>
<h4 id="针对-performTraversals大致流程如下"><a href="#针对-performTraversals大致流程如下" class="headerlink" title="针对 performTraversals大致流程如下."></a>针对 <code>performTraversals</code>大致流程如下.</h4><p><img src="https://ww3.sinaimg.cn/large/006tKfTcly1fd3x1rxbj3j30iv0c0dgr.jpg" alt=""></p>
<p><code>performTraversals</code> 会依次调用<code>performMeasure, performLayout ,performDraw</code>。其中 <code>performMeasure</code> 会调用 <code>measure</code> 方法， <code>measure</code> 最终会调用 我们自定义的 <code>onMeasure</code>。当然，对于 ViewGroup 来说，onMeasure 就是对所有子元素调用 measure 的过程</p>
<p>对于 layout 过程也是类似的。唯一不同的是 draw 方法，performDraw 传递过程是 draw 方法中通过 dispatchDraw 来实现的，但是本质是一样的。</p>
<h2 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h2><p>ViewRoot 的实现类是 ViewRootImpl ,<strong>他是链接 WindowManager 和 DecorView 的纽带，View 的三大流程均是通过 ViewRoot 来完成的，</strong></p>
<p>在 ActivityThread 中，当 Activity 对象创建完毕后，就会将 DecorView 添加到 Window 中，同时创建 ViewRootImpl,并且将 ViewRootImpl 与 DecorView 建立关联</p>
<p><strong>在 setView 中,最终会调用到 <code>ViewRootImpl</code>的 performTravelsals(),他会依次调用<code>ViewRootImpl的</code> <code>performMeasure(),performLayout(),performDraw()</code>,这番个方法会依次向下遍历,最终完成整个View数的绘制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root = new ViewRootImpl(view.getContext(),display);</div><div class="line">root.setView(view,wparams,panelParentView);</div></pre></td></tr></table></figure>
<h2 id="SpecMode-测量模式"><a href="#SpecMode-测量模式" class="headerlink" title="SpecMode 测量模式"></a>SpecMode 测量模式</h2><h3 id="EXACTLY"><a href="#EXACTLY" class="headerlink" title="EXACTLY"></a>EXACTLY</h3><p>父容器已检测出精确大小。</p>
<blockquote>
<p>对应于 <strong>match_parent</strong></p>
</blockquote>
<h3 id="AT-MOST"><a href="#AT-MOST" class="headerlink" title="AT_MOST"></a>AT_MOST</h3><p>父容器制定了可用大小 SpecSize，View 不能超过这个值。具体值要看 View 的具体实现，比如<code>TextView</code> 根据字数多少定义宽度</p>
<blockquote>
<p>对应于 <strong>wrap_content</strong></p>
</blockquote>
<h3 id="UNSPECIFIED"><a href="#UNSPECIFIED" class="headerlink" title="UNSPECIFIED"></a>UNSPECIFIED</h3><p>父容器不对 View 限制大小。一般用于系统内部，表示一种测量状态。</p>
<h2 id="View-工作流程"><a href="#View-工作流程" class="headerlink" title="View 工作流程"></a>View 工作流程</h2><h3 id="measure-过程"><a href="#measure-过程" class="headerlink" title="measure 过程"></a>measure 过程</h3><p>measure 的作用是测量 View 的宽高</p>
<p>如果是 子View，那么 measure 方法就完成了测量过程</p>
<p>如果是 ViewGroup，除了测量自身，还需要<strong>遍历去调用所有子元素的 measure 方法</strong></p>
<h4 id="onMeasure-方法"><a href="#onMeasure-方法" class="headerlink" title="onMeasure 方法"></a>onMeasure 方法</h4><h5 id="View-的-onMeasure"><a href="#View-的-onMeasure" class="headerlink" title="View 的 onMeasure"></a>View 的 onMeasure</h5><p>measure 方法会调用 onMeasure 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>setMeasureDimension 方法就会设置 View 的宽高测量值</strong></p>
<p><code>getDesaultSize()</code>返回的大小就是 <code>measureSpec 中的 specSize</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MeasureSpec.getSize(measureSpec)</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意，继承 View 的自定义控件需要重写 onMeasure 方法<strong>并且设置 wrap_content时候的自身大小</strong> 。</p>
</blockquote>
<p>因为从测量模式中得知，子View<code>wrap_content</code>模式下，他的 specMode 是 <code>AT_MOST</code>,这种情况下宽高都是 parentSize</p>
<blockquote>
<p>默认只有 <code>dp</code> 精确模式下，计算出的宽高才是 子View 的真实宽高</p>
</blockquote>
<h5 id="ViewGroup-的-onMeasure"><a href="#ViewGroup-的-onMeasure" class="headerlink" title="ViewGroup 的 onMeasure"></a>ViewGroup 的 onMeasure</h5><p>对于 ViewGroup 来说，除了完成自身的 measure 过程，还会遍历调用 子View 的 measure 方法，所以它提供了一个方法，让我们遍历调用子View</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        final int size = mChildrenCount;</div><div class="line">        final View[] children = mChildren;</div><div class="line">        for (int i = 0; i &lt; size; ++i) &#123;</div><div class="line">            final View child = children[i];</div><div class="line">            if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">            //遍历子View，调用 measureChild</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">--------------measureChild 方法------------</div><div class="line">protected void measureChild(View child, int parentWidthMeasureSpec,</div><div class="line">            int parentHeightMeasureSpec) &#123;</div><div class="line">        final LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom, lp.height);</div><div class="line">        //计算 childMeasureSpec ，然后调用 child 自身的 measure 方法</div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="layout-过程"><a href="#layout-过程" class="headerlink" title="layout 过程"></a>layout 过程</h3><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><p>layout 的作用是 <code>ViewGroup</code> 确定 子View 的位置,当 ViewGroup 的位置被确定后，他在 <code>onLayout</code> 中会遍历所有子View并调用<code>layout</code>方法,子View 的 <code>layout</code>方法又会调用 <code>onLayout</code> 方法</p>
<p><strong>自定义 ViewGroup 才需要重写 onLayout 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        int oldL = mLeft;</div><div class="line">        int oldT = mTop;</div><div class="line">        int oldB = mBottom;</div><div class="line">        int oldR = mRight;</div><div class="line">        //通过 setFrame 判断是否需要 layout</div><div class="line">        boolean changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">        //调用 onLayout 方法</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line"></div><div class="line">            if (shouldDrawRoundScrollbar()) &#123;</div><div class="line">                if(mRoundScrollbarRenderer == null) &#123;</div><div class="line">                    mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                mRoundScrollbarRenderer = null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                int numListeners = listenersCopy.size();</div><div class="line">                for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line"></div><div class="line">        if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) &#123;</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;</div><div class="line">            notifyEnterOrExitForAutoFillIfNeeded(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>setFrame 用于判断布局大小是否变过，从而判断是否需要重绘.<strong>如果布局发生过变化,会调用 invalidate() 进而调用 draw()</strong></p>
<p>onLayout 在 View 和 ViewGroup 中都没有实现，需要我们在自定义 ViewGroup 时自己实现对所有 子View 的 位置确定</p>
<h2 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h2><p>前面分析我们知道,<code>performDraw()</code>经过几个步骤和几个类,才最终调用到<code>draw(canvas)</code></p>
<p>draw 作用是将 View 绘制到屏幕上，draw 流程 遵守以下几个步骤</p>
<ul>
<li>绘制背景 <code>backgourd.draw(canvas)</code></li>
<li>绘制自身 <code>onDraw</code></li>
<li>绘制 children <code>dispatchDraw</code> ,这里与 <code>measure</code> 和 <code>layout</code> 不同，不需要手动遍历调用子View 相应方法</li>
<li>绘制装饰，比如滚动条 <code>onDrawScrollBars</code></li>
</ul>
<p>该方法比较简单，就不再看源码了。View 的绘制过程传递是通过 <code>dispatchDraw</code> 来实现的，他会遍历调用所有 子View 的 <code>draw</code> 方法</p>
<p><strong>以上就是 View 绘制流程的三个步骤</strong></p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><h4 id="getHeight-与-getMeasureHeight-有什么区别"><a href="#getHeight-与-getMeasureHeight-有什么区别" class="headerlink" title="getHeight 与 getMeasureHeight 有什么区别"></a>getHeight 与 getMeasureHeight 有什么区别</h4><ul>
<li><code>getMeasureHeight</code> 在 <code>measure</code> 结束就可获取了，而 <code>getHeight</code> 需要在 <code>layout</code> 结束才能获取</li>
<li><code>getMeasureHeight</code> 是通过 <code>setMeasuredDimission</code> 传入的值获取的。而 <code>getHeight</code> 是通过 <code>下坐标 减去 上坐标</code> 获取的</li>
<li>默认情况下两者相同，但是如果 <code>layout</code>的时候传入不恰当的值，那么就会导致获取到的值不相同</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;   </div><div class="line">    View childView = getChildAt(0);  </div><div class="line">    childView.layout(l, t, r+200, b+200);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样认为去修改错误的值，会导致最终的宽高总是多 200px</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>View的绘制流程,是从<code>ViewRootImpl</code>的<code>performTravelsals()</code>开始的,他会依次向下遍历,调用对应方法完成绘制.</p>
<p>performTraversals()会调用<code>performMeasure,performLayout(),performDraw()</code>,在这些方法的内部会对应调用<code>measure(),layout(),draw()</code>,<strong>draw()稍微复杂点,会有 SKIP_DRAW等一些标志位的判断</strong>,最终会调用到我们重写的方法<code>onMeasure(),onLayout(),onDraw()</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/03/Binder-机制/" itemprop="url">
                  Binder 机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-03T23:08:10+08:00" content="2018-01-03">
              2018-01-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/01/03/Binder-机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/03/Binder-机制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/03/Binder-机制/" class="leancloud_visitors" data-flag-title="Binder 机制">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Binder-存在的意义-为什么要使用Binder"><a href="#Binder-存在的意义-为什么要使用Binder" class="headerlink" title="Binder 存在的意义?为什么要使用Binder"></a>Binder 存在的意义?为什么要使用Binder</h3><h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。</p>
</blockquote>
<p>操作系统的不同进程之间，数据不共享；对于每个进程来说，因此一个进程需要与另外一个进程通信，需要某种系统机制才能完成。</p>
<h4 id="跨进程方式"><a href="#跨进程方式" class="headerlink" title="跨进程方式"></a>跨进程方式</h4><ul>
<li><p>Linux 传统跨进程(未严格验证通信双方身份)</p>
<ul>
<li>Socket</li>
<li>管道</li>
</ul>
</li>
<li><p>Android : <strong>Binder</strong></p>
<ul>
<li>动态可加载模块 LKM: 运行时被动态加载到内核,作为内核的一部分.成为内核与用户空间的桥梁,完成通信.Android 中称为 <code>Binder 驱动</code></li>
</ul>
</li>
</ul>
<h3 id="Binder-使用"><a href="#Binder-使用" class="headerlink" title="Binder 使用"></a>Binder 使用</h3><p>想要使用跨进程通信 Binder,最常见的就是Service中,我们首先需要创建一个 <code>aidl</code>文件,里面定义好跨进程通信的接口.</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface IRemote &#123;</div><div class="line">    int getAIDLResult(int i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们 <code>Rebuild</code> 一下,编译器会自动生成对应的 Java 文件,</p>
<h3 id="Demo-演示"><a href="#Demo-演示" class="headerlink" title="Demo 演示"></a>Demo 演示</h3><h4 id="Server-端"><a href="#Server-端" class="headerlink" title="Server 端"></a>Server 端</h4><p>我们创建一个远程 Service 对象,并且覆盖onBind() 方法并返回 IRemoteService.Stub 实例 mBinder<br>注意到 Stub 是一个抽象类,我们得实现 <code>aidl</code>文件中定义的方法.</p>
<p>Service</p>
<ul>
<li>本地服务:依附于主进程,非独立进程,无进程隔离</li>
<li>远程服务:<strong>声明android:process=”:remote”</strong>,成为独立进程,有进程隔离,需要使用AIDL进行IPC</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class RemoteService extends Service &#123;</div><div class="line"></div><div class="line">    private static final String TAG = RemoteService.class.getSimpleName();</div><div class="line">    </div><div class="line">    private  IRemote.Stub mBinder = new IRemote.Stub()&#123;</div><div class="line">        @Override</div><div class="line">        public int getAIDLResult(int result) throws RemoteException &#123;</div><div class="line">            Log.e(&quot;AIDLDemo&quot;,&quot;Service getRequest&quot;);</div><div class="line">            Log.e(&quot;AIDLDemo ; &quot;,&quot;Service pid &quot;+android.os.Process.myPid() );</div><div class="line">            return i+1;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        return mBinder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Client-端"><a href="#Client-端" class="headerlink" title="Client 端"></a>Client 端</h4><p>我们在客户端服务连接 <code>ServiceConnection</code> 的 <code>onServiceConnected()</code> 获取到了 IBinder 实例,通过 Binder 的 <code>asInterface</code> 获取到了远程服务的代理对象 <code>remoteService</code>,最后我们通过 <code>remoteService.getResult()</code> 就可以像本地方法一样调用远程服务的方法了,实现了跨进程通信.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    private ServiceConnection mConnection = new ServiceConnection() &#123;</div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">        //通过 asInterface ,获取 Binder 代理对象,调用远程方法跨进程通信</div><div class="line">            IRemote remoteService = IRemote.Stub.asInterface(service);</div><div class="line">            try &#123;</div><div class="line">                remoteService.getResult();</div><div class="line">            &#125; catch (RemoteException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        ...</div><div class="line">        //启动Service</div><div class="line">        Intent intent = new Intent(this,MyService.class);</div><div class="line">        bindService(intent,mServiceConnection,BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Q: IBinder是什么,IInterface是什么,IBinder为什么能转成IInterface</div></pre></td></tr></table></figure></p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>我们来分析一下这个文件.需要了解的地方已经写在注释中了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">public interface IRemote extends android.os.IInterface &#123;</div><div class="line">    </div><div class="line">    public static abstract class Stub extends android.os.Binder implements com.mashell.taskb.IRemote &#123;</div><div class="line">        private static final java.lang.String DESCRIPTOR = &quot;com.mashell.taskb.IRemote&quot;;</div><div class="line"></div><div class="line">        public Stub() &#123;</div><div class="line">            this.attachInterface(this, DESCRIPTOR);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //客户端通过 Stub.asInterface() 得到 Binder 代理对象,远程调用 Server 的方法,实现跨进程通信.</div><div class="line">        public static com.mashell.taskb.IRemote asInterface(android.os.IBinder obj) &#123;</div><div class="line">            if ((obj == null)) &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            //查找本地 Binder 对象</div><div class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">            //找到了而且是同一个进程,直接向上转型成 Binder 本地对象.</div><div class="line">            if (((iin != null) &amp;&amp; (iin instanceof com.mashell.taskb.IRemote))) &#123;</div><div class="line">                return ((com.mashell.taskb.IRemote) iin);</div><div class="line">            &#125;</div><div class="line">            //不是同一个进程,返回 Binder 代理对象.</div><div class="line">            return new com.mashell.taskb.IRemote.Stub.Proxy(obj);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public android.os.IBinder asBinder() &#123;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //Service端处理请求的方法</div><div class="line">        @Override</div><div class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</div><div class="line">            switch (code) &#123;</div><div class="line">                case INTERFACE_TRANSACTION: &#123;</div><div class="line">                    reply.writeString(DESCRIPTOR);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                case TRANSACTION_getResult: &#123;</div><div class="line">                    data.enforceInterface(DESCRIPTOR);</div><div class="line">                    int _arg0;</div><div class="line">                    _arg0 = data.readInt();</div><div class="line">                    //调用我们定义的方法,是抽象方法,需要在服务端实例中重写实现这个方法</div><div class="line">                    this.getResult(_arg0);</div><div class="line">                    reply.writeNoException();</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return super.onTransact(code, data, reply, flags);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //具体的代理类, 远程 Binder</div><div class="line">        private static class Proxy implements com.mashell.taskb.IRemote &#123;</div><div class="line">            private android.os.IBinder mRemote;</div><div class="line"></div><div class="line">            Proxy(android.os.IBinder remote) &#123;</div><div class="line">                mRemote = remote;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public android.os.IBinder asBinder() &#123;</div><div class="line">                return mRemote;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public java.lang.String getInterfaceDescriptor() &#123;</div><div class="line">                return DESCRIPTOR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void getResult(int result) throws android.os.RemoteException &#123;</div><div class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">                try &#123;</div><div class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    _data.writeInt(result);</div><div class="line">                   //对于跨进程调用方法,调用 transact() 这个 native 方法,要知道最终调用 talkWithDriver 方法</div><div class="line">                   //然后该函数通过 ioctl 系统调用, Client 进程陷入内核态,Client 调用我们定义的 getResult 方法线程挂起等待返回.</div><div class="line">                   //Binder 驱动操作后唤醒 Server进程,调用 Binder 本地对象的 onTransact 函数.</div><div class="line">                   //该函数通过参数判断调用到具体对应的函数.最终Binder 驱动唤醒 Client 并将结果返回.</div><div class="line">                   mRemote.transact(Stub.TRANSACTION_getResult, _data, _reply, 0);</div><div class="line">                    _reply.readException();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    _reply.recycle();</div><div class="line">                    _data.recycle();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        static final int TRANSACTION_getResult = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void getResult(int result) throws android.os.RemoteException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="asInterface"><a href="#asInterface" class="headerlink" title="asInterface()"></a>asInterface()</h4><h5 id="asInterface-拿到-IBinder-对象-让我们来分析一下这个方法"><a href="#asInterface-拿到-IBinder-对象-让我们来分析一下这个方法" class="headerlink" title="asInterface() 拿到 IBinder 对象,让我们来分析一下这个方法"></a>asInterface() 拿到 IBinder 对象,让我们来分析一下这个方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static com.mashell.taskb.IRemote asInterface(android.os.IBinder obj) &#123;</div><div class="line">            if ((obj == null)) &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">            if (((iin != null) &amp;&amp; (iin instanceof com.mashell.taskb.IRemote))) &#123;</div><div class="line">                return ((com.mashell.taskb.IRemote) iin);</div><div class="line">            &#125;</div><div class="line">            return new com.mashell.taskb.IRemote.Stub.Proxy(obj);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>Binder 会根据情况查找返回 Binder 对象,如果是同一进程就直接返回 <strong>Binder</strong> 本地对象.如果是跨进程那么就返回 <strong>BinderProxy</strong></p>
<h5 id="queryLocalInterface"><a href="#queryLocalInterface" class="headerlink" title="queryLocalInterface()"></a>queryLocalInterface()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">在 Binder 类中,查找本地 Interface 返回</div><div class="line">public IInterface queryLocalInterface(String descriptor) &#123;</div><div class="line">        if (mDescriptor.equals(descriptor)) &#123;</div><div class="line">            return mOwner;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">在 BinderProxy 中,直接返回 null</div><div class="line">public IInterface queryLocalInterface(String descriptor) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对于 asInterface,通过上面的分析,</p>
<ul>
<li>如果是同一进程直接向下转型</li>
<li>如果是跨进程的<strong>BinderProxy</strong>,返回一个 Proxy(IBinder mRemote);</li>
</ul>
<p>对于我们远程服务端方法的调用,</p>
<ul>
<li>Binder 本地对象,不需要跨进程,直接调用抽象方法</li>
<li>对于 Binder 代理对象,<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int getAIDLResult(int i) throws android.os.RemoteException &#123;</div><div class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">    int _result;</div><div class="line">    try &#123;</div><div class="line">        _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">        _data.writeInt(i);</div><div class="line">        </div><div class="line">        mRemote.transact(Stub.TRANSACTION_getAIDLResult, _data, _reply, 0);</div><div class="line">        _reply.readException();</div><div class="line">        _result = _reply.readInt();</div><div class="line">    &#125; finally &#123;</div><div class="line">        _reply.recycle();</div><div class="line">        _data.recycle();</div><div class="line">    &#125;</div><div class="line">    return _result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>重点看 <strong>transact()</strong>,既然是 BinderProxy,我们进入具体类中查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public native boolean transactNative(int code, Parcel data, Parcel reply,</div><div class="line">            int flags) throws RemoteException;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件，里面进行了一系列的函数调用，调用链实在太长这里就不给出了；要知道的是它最终调用到了talkWithDriver函数；看这个函数的名字就知道，通信过程要交给驱动完成了；这个函数最后通过ioctl系统调用，Client进程陷入内核态，Client调用add方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的onTransact函数（实际上由Server端线程池完成）。</p>
</blockquote>
<h5 id="onTransact"><a href="#onTransact" class="headerlink" title="onTransact()"></a>onTransact()</h5><p>在 <strong>BinderProxy</strong> 的transact()中,我们传入了编号,默认命名是 <strong>TRANSACTION</strong>+方法名,在 <strong>onTransact()</strong> 方法中,通过编号调用具体函数,唤醒Client 返回结果.</p>
<h3 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h3><p><img src="http://img.blog.csdn.net/20170107102830444" alt=""></p>
<h3 id="Binder-模型大致通信过程"><a href="#Binder-模型大致通信过程" class="headerlink" title="Binder 模型大致通信过程"></a>Binder 模型大致通信过程</h3><ul>
<li><p>在Android开机启动过程中，Android会初始化系统的各种Service，</p>
</li>
<li><p>将这些初始化的Service向ServiceManager注册（即让ServiceManager管理）。ServiceManager将Service名字和新建的引用填入查找表</p>
</li>
<li><p>客户端想要得到具体的Service直接向ServiceManager要即可。客户端首先向ServiceManager查询得到具体的Service引用，然后通过这个引用向具体的服务端发送请求，服务端执行完成后就返回。<strong>返回了Binder代理类</strong></p>
</li>
</ul>
<p><img src="http://img1.ph.126.net/HA21vW_pLTJ2DpMW3obuOQ==/724235115176904253.png" alt=""></p>
<h3 id="Binder-驱动"><a href="#Binder-驱动" class="headerlink" title="Binder 驱动"></a>Binder 驱动</h3><p>Binder 驱动是一段运行在内核空间的代码,他是 Binder 机制的核心,负责 Binder 节点的建立和进程间信息的传递.通过 <code>&quot;/dev/binder&quot;</code>的文件在内核空间和用户空间来回搬动数据. <code>Linux inctl</code> 函数实现了从用户空间转移到内核空间的功能.</p>
<h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><p>ServiceManager提供了注册,检索服务的功能.所有的服务由 ServiceManager 统一管理.<br>他做了三件事</p>
<ol>
<li>打开设备文件 <code>/dev/binder</code>,把文件内容映射到内核空间,借助这块区域,可以实现进程间通信.</li>
<li>将当前进程注册到 <code>Binder 驱动</code>,系统会将跨进程的服务注册到他的服务列表中.</li>
<li>ServiceManager也会进入一个无限循环,等待客户端 IPC 请求状态.</li>
</ol>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p><code>ActivityManagerService,WindowManagerService</code>等系统服务,都会调用 <code>ServiceManager.addService()</code>方法添加到 <code>ServiceManager</code>的服务列表中</p>
<ol>
<li>Server将自己作为对象,附上一个句柄为0的值(用于访问 ServiceManager),并将这些内容封装成数据报发送给 <code>Binder驱动</code></li>
<li><code>Binder驱动</code>先检查是否有Server对应的Binder实体,没有就创建 <code>Binder实体</code>并且赋予一个大于0的句柄,然后把句柄和服务名称等信息发送给ServiceManager</li>
<li>ServiceManager检查服务列表中是否有这个服务,不存在就将服务和它的句柄放入到服务列表中.</li>
</ol>
<h3 id="客户端调用服务"><a href="#客户端调用服务" class="headerlink" title="客户端调用服务"></a>客户端调用服务</h3><ol>
<li>客户端想调用某个服务,把<code>服务名+句柄0的值</code>封装成数据报发送给 <code>Binder 驱动</code></li>
<li><code>Binder驱动接收到句柄0</code>,把数据包发给 <code>ServiceManager</code></li>
<li><code>ServiceManager</code>接收到数据包后,找到对应服务,将服务的局并发给 <code>Binder驱动</code>,再发给服务端</li>
<li>客户端收到句柄后,利用句柄在本地创建 <code>远程Server的代理对象</code></li>
<li>客户端调用这个服务,会加上<code>参数,标志服</code>等数据放入 <code>Client的共享内存</code>,Binder驱动根据数据找到 <code>Server 的共享内存</code>,<strong>把数据拷贝到内核空间,并且映射到远程服务进程中,执行 onTrasact() 函数</strong></li>
<li>远程服务执行完后将结果写入自己的共享内存,<strong>Binder驱动再将数据结果拷贝到内核空间,映射到用户端进程中,唤醒客户端线程</strong></li>
</ol>
<h3 id="Binder-如何实现拷贝一次-mmap-内存映射"><a href="#Binder-如何实现拷贝一次-mmap-内存映射" class="headerlink" title="Binder 如何实现拷贝一次,mmap()内存映射"></a>Binder 如何实现拷贝一次,mmap()内存映射</h3><p>Linux 内核只有 用户空间拷贝到内核空间 <code>copy_from_user</code> 和内核空间到用户空间 <code>copy_to_user</code>.</p>
<p>为了实现一次拷贝.Binder利用<code>mmap()</code>实现<code>内核缓存区</code>与<code>接收进程用户空间</code>(接收方可以使 Server 也可以是 Client)<strong>同时映射到同一个共享接收缓存区中</strong>,这样当发送方<code>copy_from_user()</code>发送数据到内核缓存区时,由于<code>内核缓存区Binder创建的接收缓存区&amp;&amp;接收方用户空间地址存在映射关系</code>,所以也相当于发送到了接收进程的用户空间.达到跨进程通信</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-d3c78b193c3e8a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<h3 id="IBinder-IInterface-Binder-BinderProxy-Stub-代表什么"><a href="#IBinder-IInterface-Binder-BinderProxy-Stub-代表什么" class="headerlink" title="IBinder IInterface Binder BinderProxy Stub 代表什么"></a>IBinder IInterface Binder BinderProxy Stub 代表什么</h3><ul>
<li><strong>IBinder</strong> 表示跨进程传输的能力</li>
<li><strong>IInterface</strong> 代表远程服务具体有那种能力 (IRemote 继承自 IInterface)</li>
<li><strong>Binder</strong> Binder 本地对象. </li>
<li><strong>BinderProxy</strong> 远程 Binder 的代理对象,与Binder类在同一个类文件中 (文章错误)</li>
<li><p><strong>Stub</strong> Binder 本地对象抽象类,需要我们具体去实现</p>
</li>
<li><p>IActivityManager 就是一个 <code>IInterface</code>,代表远程Service具有的能力,<code>ActivityManager.getDefault()</code>是Binder本地对象,具体实现是<code>ActivityManagerService</code>,对于<code>Binder</code>代理类,就是<code>ActivityThread</code>的<code>ApplicationThread</code></p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/18/ConcurrentHashMap-源码分析/" itemprop="url">
                  ConcurrentHashMap 源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-18T19:42:13+08:00" content="2017-07-18">
              2017-07-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/18/ConcurrentHashMap-源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/18/ConcurrentHashMap-源码分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/07/18/ConcurrentHashMap-源码分析/" class="leancloud_visitors" data-flag-title="ConcurrentHashMap 源码分析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JDK1.8的时候,<code>ConcurrentHashMap</code>抛弃了分段锁机制,底层与<code>HashMap</code>一样还是<code>数组+链表</code>,采用<strong>CAS+synchronized</strong>保证并发安全</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>与<code>HashMap</code>一样,这里就不给出例子了</p>
<h3 id="成员属性分析"><a href="#成员属性分析" class="headerlink" title="成员属性分析"></a>成员属性分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//保存数据的数组</div><div class="line">transient volatile Node&lt;K,V&gt;[] table;</div><div class="line">//扩容时新生成的数组,大小为原来的两倍</div><div class="line">//当不为空的时候表示正在扩容</div><div class="line">private transient volatile Node&lt;K,V&gt;[] nextTable;</div><div class="line">//用来控制table的初始化和扩容操作</div><div class="line">private transient volatile int sizeCtl;</div></pre></td></tr></table></figure>
<p>sizeCtl:默认为0,用来控制table的初始化和扩容操作</p>
<ul>
<li><strong>-1</strong>表示正在初始化</li>
<li><strong>-N</strong>表示有<strong>N-1</strong>个线程在扩容操作(因为扩容时,n&lt;0,源码会 n+1,所以实际扩容线程<code>-(n+1)</code>)</li>
<li>其他情况<ul>
<li>如果table未初始化,表示table初始化的大小</li>
<li>table初始化完成,表示table的容量,默认是 table 的<strong>0.75倍</strong><code>(n-(n&gt;&gt;2))</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">  final int hash;</div><div class="line">  final K key;</div><div class="line">  volatile V val;</div><div class="line">  volatile Node&lt;K,V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><code>Node</code>与<code>HashMap</code>相比,<strong>value和next都用volatile修饰了</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</div><div class="line">  final Node&lt;K,V&gt;[] nextTable;</div><div class="line">  ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</div><div class="line">        //传入 hash = MOVED</div><div class="line">      super(MOVED, null, null, null);</div><div class="line">      this.nextTable = tab;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个特殊的节点,hash = -1,存储 <code>nextTable</code> 的引用</p>
<p>只有当扩容的时候,ForwardingNode 才会发挥作用,作为一个占位符放在<code>table</code>表示当前节点为<strong>null或者已被移动</strong></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public ConcurrentHashMap() &#123;&#125;</div></pre></td></tr></table></figure>
<p>默认空构造函数,如果你想传入初始化的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public ConcurrentHashMap(int initialCapacity) &#123;</div><div class="line">    //检查有效值</div><div class="line">    if (initialCapacity &lt; 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    //限定值的大小,最大不能超过 MAXIMUM_CAPACITY = 1^30 </div><div class="line">    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</div><div class="line">               MAXIMUM_CAPACITY :</div><div class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</div><div class="line">   //初始化 sizeCtl,前面说了如果没有初始化</div><div class="line">   //那么这个值表示 ,table 初始化的大小</div><div class="line">    this.sizeCtl = cap;</div><div class="line">&#125;</div><div class="line"></div><div class="line">--------------------tableSizeFor----------------</div><div class="line">//确保table的大小总是2的幂次方</div><div class="line">private static final int tableSizeFor(int c) &#123;</div><div class="line">    int n = c - 1;</div><div class="line">    n |= n &gt;&gt;&gt; 1;</div><div class="line">    n |= n &gt;&gt;&gt; 2;</div><div class="line">    n |= n &gt;&gt;&gt; 4;</div><div class="line">    n |= n &gt;&gt;&gt; 8;</div><div class="line">    n |= n &gt;&gt;&gt; 16;</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="put-函数"><a href="#put-函数" class="headerlink" title="put 函数"></a>put 函数</h3><p>put() 用于添加/修改元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">    if (key == null || value == null) throw new NullPointerException();</div><div class="line">    //计算 key的hash,比 HashMap 多了 [&amp; HASH_BITS(0x7fffffff)]</div><div class="line">    int hash = spread(key.hashCode());</div><div class="line">    int binCount = 0;</div><div class="line">    //插入操作,是一个死循环</div><div class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">        //第一次 put的时候才会初始化 table,我们后面分析 initTable()</div><div class="line">        if (tab == null || (n = tab.length) == 0)</div><div class="line">            tab = initTable();</div><div class="line">        //利用 [(n-1) &amp; hash] 获取 数组 index,与 HashMap 一致</div><div class="line">        //然后用 CAS 操作拿到 index 对应的数组值</div><div class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">        //null 表示数组对应位置还没有元素,那么直接 CAS 操作放入元素值即可</div><div class="line">        //方法内部就是 CAS 操作,CAS操作成功才会返回 true,直接跳出 for死循环</div><div class="line">        //CAS操作失败,证明有其他线程在修改值最外层 for死循环一直自旋,直到成功插入元素</div><div class="line">            if (casTabAt(tab, i, null,</div><div class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                break;                   </div><div class="line">        &#125;</div><div class="line">        //如果 hash = MOVED(-1),前面分析 ForwardingNode </div><div class="line">        //说了代表其他线程正在扩容,那么一起扩容</div><div class="line">        else if ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        else &#123;</div><div class="line">        //其他正常情况,就把节点插入到链表或者红黑树的合适位置</div><div class="line">            V oldVal = null;</div><div class="line">            //利用 synchronized,保证 put 并发安全</div><div class="line">            synchronized (f) &#123;</div><div class="line">            //利用CAS拿到数组对应 index 值</div><div class="line">                if (tabAt(tab, i) == f) &#123;</div><div class="line">                //是普通链表</div><div class="line">                    if (fh &gt;= 0) &#123;</div><div class="line">                        binCount = 1;</div><div class="line">                        //循环遍历链表</div><div class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            //判断 [节点hash相等 &amp; (节点.key相等 || 节点.key的内容相等)]</div><div class="line">                            //相等表示碰撞了,找到旧元素了,就覆盖旧值</div><div class="line">                            //与 HashMap 一致</div><div class="line">                            if (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                                if (!onlyIfAbsent)</div><div class="line">                                //覆盖旧值</div><div class="line">                                    e.val = value;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            //遍历到链表尾部还是没有旧值,证明后面没有元素碰撞</div><div class="line">                            //那就将元素插入到链表尾部</div><div class="line">                            if ((e = e.next) == null) &#123;</div><div class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, null);</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    //是红黑树</div><div class="line">                    else if (f instanceof TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = 2;</div><div class="line">                        //利用红黑树插入</div><div class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != null) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            //覆盖旧值</div><div class="line">                            if (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (binCount != 0) &#123;</div><div class="line">            //如果碰撞长度超过 TREEIFY_THRESHOLD = 8,转成红黑树</div><div class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">            //返回旧值</div><div class="line">                if (oldVal != null)</div><div class="line">                    return oldVal;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //只有前面的 数组 index 为null或者普通链表的覆盖旧值以及插入新值有 break</div><div class="line">    //才会执行 addCount,检查是否需要扩容</div><div class="line">    addCount(1L, binCount);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>put()</code>流程大致如下</p>
<ul>
<li>table 为null,没有初始化,那么先 <code>initTable</code>初始化</li>
<li>利用 <code>[(n-1)&amp;hash]</code> 计算数组索引index<ul>
<li>利用 CAS 获取数组index 的值,如果为null,直接CAS插入<ul>
<li>插入成功的话 return</li>
<li>失败的话外层是 <code>for死循环</code>,会自旋直到插入成功</li>
</ul>
</li>
<li>CAS 获取数组index的值,发现 <code>hash = MOVED = -1</code>的话,表示其他线程正在进行扩容,那么一起参与扩容</li>
<li>否则为其他情况,链表或者红黑树,利用<code>Synchronized</code>保证并发安全<ul>
<li>如果是普通链表的话,遍历链表<ul>
<li>如果 <code>[节点hash相等 &amp; (节点.key相等 || 节点.key的内容相等)]</code>,证明找到了旧值,直接覆盖旧值</li>
<li>如果遍历到链表尾部还没找到旧值,证明是新元素,插入到链表尾部</li>
</ul>
</li>
<li>如果是红黑树的话利用红黑树插入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="get-函数"><a href="#get-函数" class="headerlink" title="get() 函数"></a>get() 函数</h3><p>get() 用于获取元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</div><div class="line">    //计算 hash</div><div class="line">    int h = spread(key.hashCode());</div><div class="line">    //利用 CAS 获取数组对应 index 的值</div><div class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</div><div class="line">        //利用 [节点hash相等 &amp;(节点.key相等 || 节点.key内容相等)]</div><div class="line">        //先判断链首,看是否命中</div><div class="line">        if ((eh = e.hash) == h) &#123;</div><div class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</div><div class="line">            //命中就返回值</div><div class="line">                return e.val;</div><div class="line">        &#125;</div><div class="line">        //hash&lt;0,证明是红黑树的叶子节点,遍历红黑树</div><div class="line">        else if (eh &lt; 0)</div><div class="line">            return (p = e.find(h, key)) != null ? p.val : null;</div><div class="line">        //否则,遍历链表</div><div class="line">        while ((e = e.next) != null) &#123;</div><div class="line">            if (e.hash == h &amp;&amp;</div><div class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</div><div class="line">                return e.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()函数大致流程如下</p>
<ul>
<li>如果table为null,直接返回 null</li>
<li>首先判断链表第一个节点(也就是数组index的值)是否命中</li>
<li>接着在红黑树中查找</li>
<li>最后在链表中查找</li>
</ul>
<h3 id="remove-函数"><a href="#remove-函数" class="headerlink" title="remove() 函数"></a>remove() 函数</h3><p>remove() 用于删除元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">//value传入 null,代表要删除</div><div class="line">final V replaceNode(Object key, V value, Object cv) &#123;</div><div class="line">    int hash = spread(key.hashCode());</div><div class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">        //数组没有初始化,直接 return</div><div class="line">        if (tab == null || (n = tab.length) == 0 ||</div><div class="line">            (f = tabAt(tab, i = (n - 1) &amp; hash)) == null)</div><div class="line">            break;</div><div class="line">        //其他线程正在扩容,一起参与扩容</div><div class="line">        else if ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        else &#123;</div><div class="line">            V oldVal = null;</div><div class="line">            boolean validated = false;</div><div class="line">            //其他情况,链表/红黑树,采用 synchronized 保证并发安全</div><div class="line">            synchronized (f) &#123;</div><div class="line">                if (tabAt(tab, i) == f) &#123;</div><div class="line">                    if (fh &gt;= 0) &#123;</div><div class="line">                        validated = true;</div><div class="line">                        //是链表,for循环遍历整条链表</div><div class="line">                        for (Node&lt;K,V&gt; e = f, pred = null;;) &#123;</div><div class="line">                            K ek;</div><div class="line">                            //[(节点hash相等&amp;(节点.key相等||节点.key内容相等))],证明找到了节点</div><div class="line">                            </div><div class="line">                            if (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                V ev = e.val;</div><div class="line">                                if (cv == null || cv == ev ||</div><div class="line">                                    (ev != null &amp;&amp; cv.equals(ev))) &#123;</div><div class="line">                                    oldVal = ev;</div><div class="line">                                    //value != null,表示修改值,不是删除</div><div class="line">                                    if (value != null)</div><div class="line">                                        e.val = value;</div><div class="line">                                   //是删除值,那么链表操作,移除节点</div><div class="line">                                    else if (pred != null)</div><div class="line">                                        pred.next = e.next;</div><div class="line">                                    else</div><div class="line">                                //首节点,因为是数组就用CAS操作修改值为链表下一个节点</div><div class="line">                                        setTabAt(tab, i, e.next);</div><div class="line">                                &#125;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                            //指针指向下一个链表节点</div><div class="line">                            pred = e;</div><div class="line">                            //没有找到,直接结束</div><div class="line">                            if ((e = e.next) == null)</div><div class="line">                                break;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    else if (f instanceof TreeBin) &#123;</div><div class="line">                        validated = true;</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; r, p;</div><div class="line">                        if ((r = t.root) != null &amp;&amp;</div><div class="line">                            (p = r.findTreeNode(hash, key, null)) != null) &#123;</div><div class="line">                            V pv = p.val;</div><div class="line">                            if (cv == null || cv == pv ||</div><div class="line">                                (pv != null &amp;&amp; cv.equals(pv))) &#123;</div><div class="line">                                oldVal = pv;</div><div class="line">                                //value != null,表示修改值</div><div class="line">                                if (value != null)</div><div class="line">                                    p.val = value;</div><div class="line">                                //红黑树删除节点</div><div class="line">                                else if (t.removeTreeNode(p))</div><div class="line">                                    setTabAt(tab, i, untreeify(t.first));</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (validated) &#123;</div><div class="line">                if (oldVal != null) &#123;</div><div class="line">                    if (value == null)</div><div class="line">                        addCount(-1L, -1);</div><div class="line">                    return oldVal;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>remove()函数比较简单,在几种不同的情况下分别按照各自办法删除节点即可</p>
<h3 id="initTable-初始化"><a href="#initTable-初始化" class="headerlink" title="initTable() 初始化"></a>initTable() 初始化</h3><p>CHM的table初始化不在构造函数,而在第一次 put 节点的时候,源码比较简单,就是在判断<code>sizeCtl &gt;=0</code>(这样才表示其他线程没有初始化或者没有扩容)的情况下,new了数组,同时利用<code>CAS</code>操作修改<code>sizeCtl</code>为-1,告诉其他线程table正在扩容,初始化成功修改回<code>sizeCtl</code>的值</p>
<h3 id="addCount-扩容"><a href="#addCount-扩容" class="headerlink" title="addCount() 扩容"></a>addCount() 扩容</h3><p>在分析 <code>put()</code>的时候,最后会调用<code>addCount</code>表示检查是否需要扩容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private final void addCount(long x, int check) &#123;</div><div class="line">    ... 省略部分代码</div><div class="line">    //check&gt;0才能扩容,其他情况表示有其他线程正在扩容</div><div class="line">    if (check &gt;= 0) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class="line">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">            int rs = resizeStamp(n);</div><div class="line">            // sizeCtl &lt;0表示其他线程在扩容</div><div class="line">            if (sc &lt; 0) &#123;</div><div class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div class="line">                    transferIndex &lt;= 0)</div><div class="line">                    break;</div><div class="line">                //CAS修改 sizeCtl的值+1,表示只有一个线程能够扩容</div><div class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</div><div class="line">                transfer(tab, null);</div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>addCount 会通过判断 sizeCtl 的值来决定是否需要扩容,利用<code>transfer()</code>实现扩容的后数组的大小为原来的<code>2倍</code>,实际大小为原来的<code>1,5倍</code>(loadFactory),然后拷贝旧数据到新的数组中,然后构造反序链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用<code>Unsafe.putObjectVolatile</code>方法给table原位置赋值fwd.具体过程可以看<a href="https://www.jianshu.com/p/f6730d5784ad" target="_blank" rel="external">这篇文章</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>1.8的CHM利用了<code>CAS+Synchronized</code>保证并发的安全,扩容也是原来数组的<code>2倍</code></li>
<li>判断节点是否冲突与<code>HashMap</code>一样,<code>[节点hash相等&amp;[节点.key相等||节点.key内容相等]]</code>.</li>
<li>CHM全局有一个<code>sizeCtl</code>,他是一个标志位,可以在并发的情况下告诉其他线程当前的数组容器状态(初始化/扩容中/扩容完成)等,从而让其他线程根据实际情况作出相应操作.</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/c0642afe03e0" target="_blank" rel="external">深入浅出ConcurrentHashMap1.8</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/06/LinkedHashMap-源码分析/" itemprop="url">
                  LinkedHashMap 源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-06T20:32:13+08:00" content="2017-07-06">
              2017-07-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/06/LinkedHashMap-源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/06/LinkedHashMap-源码分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/07/06/LinkedHashMap-源码分析/" class="leancloud_visitors" data-flag-title="LinkedHashMap 源码分析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">LinkedHashMap&lt;String, Integer&gt; lmap = new LinkedHashMap&lt;String, Integer&gt;();</div><div class="line">lmap.put(&quot;语文&quot;, 1);</div><div class="line">lmap.put(&quot;数学&quot;, 2);</div><div class="line">for(Entry&lt;String, Integer&gt; entry : lmap.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap 继承自 HashMap</p>
<h3 id="成员属性分析"><a href="#成员属性分析" class="headerlink" title="成员属性分析"></a>成员属性分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//头结点</div><div class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</div><div class="line">//尾节点</div><div class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</div><div class="line">//true表示实现FIFO的顺序排列元素,false表示按照插入顺序排列元素</div><div class="line">final boolean accessOrder;</div></pre></td></tr></table></figure>
<p>LinkedHashMap 保存了头尾节点,内部实现是<strong>双链表</strong></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public LinkedHashMap() &#123;</div><div class="line">    super();</div><div class="line">    accessOrder = false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三个重要的函数"><a href="#三个重要的函数" class="headerlink" title="三个重要的函数"></a>三个重要的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</div><div class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</div><div class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</div></pre></td></tr></table></figure>
<h4 id="afterNodeAccess函数"><a href="#afterNodeAccess函数" class="headerlink" title="afterNodeAccess函数"></a>afterNodeAccess函数</h4><p>访问链表节点后的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; </div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">    //p作为指针,b为p的前指针,a为p的后指针</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        //p的后节点置null</div><div class="line">        p.after = null;</div><div class="line">        if (b == null)</div><div class="line">            head = a;</div><div class="line">        else</div><div class="line">        //设置 before 的后节点,为了移除 p</div><div class="line">            b.after = a;</div><div class="line">        if (a != null)</div><div class="line">        //设置 after 的前节点,为了移除 p</div><div class="line">            a.before = b;</div><div class="line">        else</div><div class="line">            last = b;</div><div class="line">        //空链表,那么 p 就是头结点</div><div class="line">        if (last == null)</div><div class="line">            head = p;</div><div class="line">        else &#123;</div><div class="line">        //将移除的P节点,移动到链表尾部</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到,这个函数就是为了访问元素后,将元素移动到链表尾部,保证 FIFO</p>
<h4 id="afterNodeInsertion函数"><a href="#afterNodeInsertion函数" class="headerlink" title="afterNodeInsertion函数"></a>afterNodeInsertion函数</h4><p>节点插入后的操作,可能会因为超过容量而移除最早最少使用的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void afterNodeInsertion(boolean evict) &#123; </div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        //移除第一个元素,也就是最近最少使用的元素</div><div class="line">        removeNode(hash(key), key, null, false, true);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="afterNodeRemoval函数"><a href="#afterNodeRemoval函数" class="headerlink" title="afterNodeRemoval函数"></a>afterNodeRemoval函数</h4><p>用于移除节点操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">    p.before = p.after = null;</div><div class="line">    if (b == null)</div><div class="line">        head = a;</div><div class="line">    else</div><div class="line">        b.after = a;</div><div class="line">    if (a == null)</div><div class="line">        tail = b;</div><div class="line">    else</div><div class="line">        a.before = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="以上三个函数就是为了保证链表始终保持最近最少使用的规则"><a href="#以上三个函数就是为了保证链表始终保持最近最少使用的规则" class="headerlink" title="以上三个函数就是为了保证链表始终保持最近最少使用的规则"></a>以上三个函数就是为了保证链表始终保持最近最少使用的规则</h4><h3 id="put-函数"><a href="#put-函数" class="headerlink" title="put()函数"></a>put()函数</h3><p>put函数在LinkedHashMap中未重新实现，只是实现了afterNodeAccess和afterNodeInsertion两个回调函数。</p>
<p>对于<code>LinkedHashMap</code>的put(),每次操作都会调用<code>afterNodeAccess()</code>,这样就将节点插入到双链表了.</p>
<h3 id="get-函数"><a href="#get-函数" class="headerlink" title="get()函数"></a>get()函数</h3><p>get()则重新实现了,在函数中加入了 <code>accessOrder</code> 来保证访问顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    if ((e = getNode(hash(key), key)) == null)</div><div class="line">        return null;</div><div class="line">    //如果是需要按照访问的顺序排序</div><div class="line">    if (accessOrder)</div><div class="line">    //回调这个方法,实现是将元素放在最后面</div><div class="line">        afterNodeAccess(e);</div><div class="line">    return e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://img2.ph.126.net/6h6Q_uZfZJyGMEqRVeJEmQ==/6631626317608930421.png"
               alt="mashell" />
          <p class="site-author-name" itemprop="name">mashell</p>
          <p class="site-description motion-element" itemprop="description">还有什么比不浪费时间更有意义的事呢？</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mashell</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"mashell"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("F8tDrPhvnflgmUOz88q2X3v8-gzGzoHsz", "7G2z5hgOyivnxFAKfLDqhTfK");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
