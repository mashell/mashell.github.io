<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="还有什么比不浪费时间更有意义的事呢？">
<meta property="og:type" content="website">
<meta property="og:title" content="mashell">
<meta property="og:url" content="http://mashell.cn/index.html">
<meta property="og:site_name" content="mashell">
<meta property="og:description" content="还有什么比不浪费时间更有意义的事呢？">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mashell">
<meta name="twitter:description" content="还有什么比不浪费时间更有意义的事呢？">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://mashell.cn/"/>


  <title> mashell </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">mashell</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">你热爱生命吗？那别浪费时间</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="http://mashell.cn/resume/" rel="section">
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/02/invalidate-requestLayout与ViewGroup-draw/" itemprop="url">
                  Invalidate 与 requestLayout,ViewGroup.draw() 区别与联系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-02T15:33:44+08:00" content="2018-04-02">
              2018-04-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/02/invalidate-requestLayout与ViewGroup-draw/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/02/invalidate-requestLayout与ViewGroup-draw/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/04/02/invalidate-requestLayout与ViewGroup-draw/" class="leancloud_visitors" data-flag-title="Invalidate 与 requestLayout,ViewGroup.draw() 区别与联系">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h2><ul>
<li><code>requestLayout</code> 会调用 <code>ViewGroup 的 requestLayout</code>,直到 <code>ViewRootImpl</code> 的 <code>requestLayout</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void requestLayout() &#123;</div><div class="line">        if (mMeasureCache != null) mMeasureCache.clear();</div><div class="line"></div><div class="line">        if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123;</div><div class="line">           </div><div class="line">            ViewRootImpl viewRoot = getViewRootImpl();</div><div class="line">            if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123;</div><div class="line">                if (!viewRoot.requestLayoutDuringLayout(this)) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            mAttachInfo.mViewRequestingLayout = this;</div><div class="line">        &#125;</div><div class="line">        //将当前 标志 设置 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED</div><div class="line">        mPrivateFlags |= PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags |= PFLAG_INVALIDATED;</div><div class="line">        //调用父类的requestLayout，父类也会被设置标志 PFLAG_FORCE_LAYOUT</div><div class="line">        if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;</div><div class="line">            mParent.requestLayout();</div><div class="line">        &#125;</div><div class="line">        if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123;</div><div class="line">            mAttachInfo.mViewRequestingLayout = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>ViewRootImpl 的 requestLayout 最终会执行<code>performTravels()</code>,会依次调用<code>measure(),layout(),draw()</code>三个方法</p>
<h3 id="measure"><a href="#measure" class="headerlink" title="measure()"></a>measure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">       ...</div><div class="line">       //判断是否设置了标志位 PFLAG_FORCE_LAYOUT,requestLayout 设置了</div><div class="line">        final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if (forceLayout || needsLayout) &#123;</div><div class="line">            ...</div><div class="line">            //由于设置了标志位,所以执行 onMeaure()</div><div class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">               ...</div><div class="line">                ...</div><div class="line">        //设置了 PFLAG_LAYOUT_REQUIRED, layout 中有作用</div><div class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以看到,由于我们 requestLayout 设置了 <code>PFLAG_FORCE_LAYOUT</code>,所以在 measure 会执行 <code>onMeasure()</code>方法,该方法末尾设置了标志位 <code>PFLAG_LAYOUT_REQUIRED</code></p>
</blockquote>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">        ...</div><div class="line">        //如果view布局变了,setFrame 会返回 true</div><div class="line">        boolean changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line">        //如果布局变了,或者设置了 PFLAG_LAYOUT_REQUIRED,则执行 onLayout</div><div class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            //在执行完onLayout方法之后，从mPrivateFlags中移除标签PFLAG_LAYOUT_REQUIRED</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line">            &#125;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在 layout 方法中,由于我们在 meaesure 设置了 <code>PFLAG_LAYOUT_REQUIRED</code>,所以会执行 onLayout() 方法</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>在 requestLayout 过程中，View 以及 父View 不断被设置标志 <code>PFLAG_FORCE_LAYOUT</code>,View 还设置了<code>PFLAG_INVALIDATED</code>,那么最后 performTravel时，<code>measure</code>检测到了标志位，一定会 <code>measure</code>，*</strong></li>
<li><strong>调用了 measure().该方法最后会设置 <code>PFLAG_FORCE_LAYOUT</code>,所以layout()会执行<code>onLayout()</code>方法</strong></li>
<li>调用 <code>requestLayout</code>的View以及他的父View <strong>都会进行 measure(),layout()</strong></li>
<li>对于 onDraw 会否执行,分两种情况<ul>
<li>如果<code>requestLayout</code>过程,layout没有改变<code>l,t,r,b</code>那么在 <code>performDraw</code>过程中，<code>mDirty</code>为空，所以onDraw不会被执行</li>
<li>如果<code>requestLayout</code>过程,layout导致<code>l,t,r,b</code>不一样了,那么在<strong>setFrame</strong>中,会调用<code>invalidate()</code>(源码太长不展示了),从而执行 <code>onDraw</code>.</li>
</ul>
</li>
</ul>
<h2 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h2><ul>
<li>我们调用 <code>invalidate</code> 方法，最终调用到<code>invalidateInternal</code>.他会设置两个标志位<code>FLAG_INVALIDATED</code>和<code>PFLAG_DRAWING_CACHE_VALID</code>，<code>PFLAG_INVALIDATED</code>置为 <strong>1</strong>，<code>PFLAG_DRAWING_CACHE_VALID</code>置为<strong>0</strong>.  。 接着会调用 父View 的 <code>invalidateChild</code></li>
<li><code>invalidateChild</code>,它里面是一个 while 循环，一直遍历查找 父View，调用 <code>ViewGroup的invalidateChild()</code>。,进而调用<code>invalidateChildInParent()</code>,<strong>该方法清除了 PFLAG_DRAWING_CACHE_VALID 标志</strong>，他们的标志位都会设置<code>PFLAG_DRAWING_CACHE_VALID置为0</code>。(为了筛选出View所在的链，排除其他无关链)</li>
<li>最终，会执行到 <code>ViewRoot</code> 的 <code>invalidateChildInParent</code></li>
<li>在 <code>ViewRoot</code> 的 <code>invalidateChildInParent</code> 中，会调用 <code>scheduleTraversals</code></li>
<li><code>scheduleTraversals</code> <strong>由于没有<code>PFLAG_FORCE_LAYOUT</code>,所以不会调用 <code>measure()</code> 进而不会调用<code>layout()</code>,</strong> 最终进入<code>performDraw()</code>执行<code>mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this);</code></li>
<li><code>draw(mView, mAttachInfo, this)</code>会调用<code>ThreadedRenderer.updateRootDisplayList() -&gt; ThreadedRenderer.updateViewTreeDisplayList() -&gt; View.updateDisplayListIfDirty()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private void updateViewTreeDisplayList(View view) &#123;</div><div class="line">        view.mPrivateFlags |= View.PFLAG_DRAWN;</div><div class="line">        //这里根据 PFLAG_INVALIDATED 设置了 mRecreateDisplayList</div><div class="line">        //如果是需要重绘的View,那么 mRecreateDisplayList 此时就会设置为 true</div><div class="line">        //其他view 依旧false</div><div class="line">        view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)</div><div class="line">                == View.PFLAG_INVALIDATED;</div><div class="line">        view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;</div><div class="line">        //进行更新视图操作,内部是根据情况调用 draw 方法</div><div class="line">        view.updateDisplayListIfDirty();</div><div class="line">        //调用结束,清除设置的状态 false</div><div class="line">        view.mRecreateDisplayList = false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们前面设置了 view 的<code>PFLAG_INVALIDATED</code>为1,<code>PFLAG_DRAWING_CACHE_VALID</code>为0.他的 parentView 为<code>PFLAG_DRAWING_CACHE_VALID</code>和<code>PFLAG_INVALIDATED</code>都为0. <strong>这样我们可以通过 PFLAG_DRAWING_CACHE_VALID 找到那条View链是有关联系,然后通过<code>PFLAG_INVALIDATED</code>知道了哪个View需要重绘</strong>,重绘View.mRecreateDisplayList 为 true</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public RenderNode updateDisplayListIfDirty() &#123;</div><div class="line">        final RenderNode renderNode = mRenderNode;</div><div class="line">        ...</div><div class="line">        // PFLAG_DRAWING_CACHE_VALID 前面设置的标志位,</div><div class="line">        // 表示这条链与需要重绘的View有关</div><div class="line">        if ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0</div><div class="line">                || !renderNode.isValid()</div><div class="line">            //mRecreateDisplayList 表示不是重绘view本身</div><div class="line">            if (renderNode.isValid()</div><div class="line">                    &amp;&amp; !mRecreateDisplayList) &#123;</div><div class="line">                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</div><div class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</div><div class="line">                //继续分发事件,循环调用childView.recreateChildDisplayList()</div><div class="line">                //最终还是调用 view.updateDisplayListIfDirty()</div><div class="line">                dispatchGetDisplayList();</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">            //走到这里,mRecreateDisplayList = true,是重绘view本身</div><div class="line">                if (layerType == LAYER_TYPE_SOFTWARE) &#123;</div><div class="line">                    ...</div><div class="line">                &#125; else &#123;</div><div class="line">                    ...</div><div class="line">                    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</div><div class="line">                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</div><div class="line">                    </div><div class="line">                    if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</div><div class="line">                        //重绘 View 是 ViewGroup,而且 PFLAG_SKIP_DRAW 直接绘制子View</div><div class="line">                        dispatchDraw(canvas);</div><div class="line">                        ...</div><div class="line">                    &#125; else &#123;</div><div class="line">                        //绘制view本身</div><div class="line">                        draw(canvas);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; </div><div class="line">            ...</div><div class="line">        &#125; else &#123;</div><div class="line">            ...</div><div class="line">            //不是 view 本身,也不是View相关父View,直接结束</div><div class="line">        &#125;</div><div class="line">        return renderNode;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>可以看到,绘制方法通过<code>PFLAG_DRAWING_CACHE_VALID</code>找到了有关联的View链,然后通过<code>PFLAG_INVALIDATED</code>找到了具体需要重绘的那个View,有以下几种情况</strong><ul>
<li><code>重绘View</code>本身,<code>PFLAG_DRAWING_CACHE_VALID = 0</code>而且<code>PFLAG_INVALIDATED = 1</code>.那么走到 <code>draw(canvas)</code>进行绘制.</li>
<li><code>重绘View的父View</code>,<code>PFLAG_DRAWING_CACHE_VALID = 0</code>,那么走到 <code>dispatchGetDisplayList()</code>继续分发事件给子View,最终还是回到<code>updateDisplayListIfDirty()</code></li>
<li>其他View链上的View,<code>PFLAG_DRAWING_CACHE_VALID = 1</code>,直接结束</li>
</ul>
</li>
</ul>
<p><strong>但是整个过程中，View没有强制重新测量的标志位 <code>PFLAG_FORCE_LAYOUT</code>,所以不会执行 <code>measure</code> 方法，没有进入 measure 方法，也就不会设置 <code>PFLAG_LAYOUT_REQUIRED</code>,那么在 <code>onLayout</code> 方法中，也就不会执行 onLayout 进行重新布局了</strong></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>invalidate 的实现依靠两个标志位</p>
<ul>
<li>PFLAG_DRAWING_CACHE_VALID</li>
<li>PFLAG_INVALIDATED</li>
</ul>
<p><strong>PFLAG_INVALIDATED 来判断哪个View 需要重绘，只有它会进行重绘，而<code>PFLAG_DRAWING_CACHE_VALID</code>用于判断是否继续分发，不是 View 所在的 View链，不会进行分发，节省时间。</strong></p>
<h2 id="ViewGroup-draw"><a href="#ViewGroup-draw" class="headerlink" title="ViewGroup.draw()"></a>ViewGroup.draw()</h2><p>对于 <code>draw(canvas)</code>,会在<code>performTraversals() -&gt; performDraw() -&gt; mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this); -&gt; ThreadedRenderer.updateRootDisplayList() -&gt; ThreadedRenderer.updateViewTreeDisplayList() -&gt; View.updateDisplayListIfDirty()</code>被调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void updateDisplayListIfDirty()&#123;</div><div class="line">if (!hasDisplayList) &#123; //软件绘制</div><div class="line">    // Fast path for layouts with no backgrounds</div><div class="line">    if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;      </div><div class="line">        //跳过当前View的绘制,直接绘制子view</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</div><div class="line">        dispatchDraw(canvas);</div><div class="line">    &#125; else &#123;                            </div><div class="line">        //此时坐标系已经切换到View自身坐标系了,可以纯碎的绘制当前view了,又回到了draw(canvas)</div><div class="line">        draw(canvas);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到,会判断当前View是否需要绘制(通过<code>PFLAG_SKIP_DRAW</code>标志).</p>
<ul>
<li>若 mPrivateFlags <strong>包含</strong><code>PFLAG_SKIP_DRAW</code>,那么直接<strong>跳过</strong>当前View的<code>draw(canvas)</code>,直接调用<code>dispatchDraw</code>绘制当前View的子View</li>
<li>若 mPrivateFlags <strong>不包含</strong><code>PFLAG_SKIP_DRAW</code>,那么会<strong>调用</strong> draw 方法</li>
</ul>
<p>而对于 ViewGroup 初始化的时候,他会调用 <code>initViewGroup()</code> 方法 ,会初始化一些 Flag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private void initViewGroup() &#123;</div><div class="line">    // ViewGroup doesn&apos;t draw by default</div><div class="line">    if (!debugDraw()) &#123;</div><div class="line">        setFlags(WILL_NOT_DRAW, DRAW_MASK);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于 <code>setFlags()</code> 方法,从源码中(篇幅太长不贴源码)可以看出,如果<strong>有 WILL_NOT_DRAW或者当前View没有背景</strong>,那么就会设置 <strong>PFLAG_SKIP_DRAW</strong>标志位,而这个标志位在 <code>draw(Canvas canvas, ViewGroup parent, long drawingTime) -&gt; ThreadedRenderer.updateRootDisplayList()  -&gt; ThreadedRenderer.updateViewTreeDisplayList() -&gt; View.updateDisplayListIfDirty()</code>方法中进行了判断,从而选择是否绘制本身</p>
<blockquote>
<p>所以可以看到,因为 <code>WILL_NOT_DRAW</code>标志位,所以ViewGroup 默认不执行 draw() 方法</p>
</blockquote>
<h3 id="setWillNotDraw"><a href="#setWillNotDraw" class="headerlink" title="setWillNotDraw"></a>setWillNotDraw</h3><p>View 还有一个重要的方法,来设置清除上面的标志位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void setWillNotDraw(boolean willNotDraw) &#123;  </div><div class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们想调用 ViewGroup 的 <code>draw(canvas)</code> 方法,我们得调用<code>setWillNotDraw(false)</code>来手动清除 <code>FALG</code>,以达到目的.</p>
<h3 id="ViewGroup-onDraw"><a href="#ViewGroup-onDraw" class="headerlink" title="ViewGroup.onDraw()"></a>ViewGroup.onDraw()</h3><p>在 View 的 <code>draw</code> 方法中,有一个标志位,他来判断是否需要 onDraw()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void draw(Canvas canvas) &#123;</div><div class="line">    final int privateFlags = mPrivateFlags;</div><div class="line">    final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">    ...</div><div class="line">    //判断是否需要调用 onDraw</div><div class="line">    if (!dirtyOpaque) onDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以说,即使 <code>draw()</code> 调用了,<code>onDraw()</code>也不一定执行,他必须满足 <code>dirtyOpaque = false</code> 也就是没有设置 <code>PFLAG_DIRTY_OPAQUE</code>,这个 flag 相关逻辑在<code>ViewGroup.invalidateChild()</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//这里的child表示直接调用invalidate的子View。</div><div class="line">public final void invalidateChild(View child, final Rect dirty) &#123;</div><div class="line">//计算子View是否是实心的</div><div class="line">final boolean isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp; child.getAnimation() == null &amp;&amp; childMatrix.isIdentity();</div><div class="line">//PFLAG_DIRTY和PFLAG_DIRTY_OPAQUE是互斥的</div><div class="line">int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</div><div class="line"></div><div class="line">do &#123; //循环遍历到ViewRootImpl为止</div><div class="line">    View view = null;//父View</div><div class="line">    if (parent instanceof View) &#123;</div><div class="line">        view = (View) parent;</div><div class="line">    &#125;</div><div class="line">    if (view != null) &#123; //给当前父View打上相应的flag</div><div class="line">        //父View若包含FADING_EDGE_MASK标识，那么只能打上FLAG_DIRTY标识</div><div class="line">        //表示会调用ViewGroup.onDraw方法</div><div class="line">        if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp;</div><div class="line">                            view.getSolidColor() == 0) &#123;</div><div class="line">            opaqueFlag = PFLAG_DIRTY;</div><div class="line">        &#125;</div><div class="line">        if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</div><div class="line">            //父View 不包含 FADING_EDGE_MASK标识</div><div class="line">            //那么打上 PFLAG_DIRTY_OPAQUE</div><div class="line">            //PFLAG_DIRTY和PFLAG_DIRTY_OPAQUE是互斥的</div><div class="line">            view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PFLAG_DIRTY和PFLAG_DIRTY_OPAQUE是互斥的</p>
<p>可以看到, View.invalidate 会最终调用到<code>ViewRootImpl的方法</code>,若子View是实心的,<strong>会将父控件标记为 <code>PFLAG_DIRTY_OPAQUE</code></strong>,否则为<code>PFLAG_DIRTY</code>,对于<code>PFLAG_DIRTY_OPAQUE</code>的View,绘制过程中,<strong>会跳过 <code>drawBackgroud() 和onDraw()</code>方法</strong>(分析<code>draw(canvas)</code>说过)</p>
<p><strong>PFLAG_DIRTY 会导致跳过 drawBackgroud 和 onDraw() 方法,这个标志对于 子View 的父ViewGroup有用,这样就能保证实心的View不多余的绘制父类部分</strong></p>
<h4 id="computeOpaqueFlags"><a href="#computeOpaqueFlags" class="headerlink" title="computeOpaqueFlags()"></a>computeOpaqueFlags()</h4><p>决定一个View是否实心,取决于<code>child.isOpaque</code>,而这个方法实质是调用<code>computeOpaqueFlags()</code>计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> protected void computeOpaqueFlags() &#123;</div><div class="line">    // Opaque if:</div><div class="line">    //   - Has a background</div><div class="line">    //   - Background is opaque</div><div class="line">    //   - Doesn&apos;t have scrollbars or scrollbars overlay</div><div class="line">    //若View包含背景，且背景是不透明的，则打上PFLAG_OPAQUE_BACKGROUND标识</div><div class="line">    if (mBackground != null &amp;&amp; mBackground.getOpacity() == PixelFormat.OPAQUE) &#123;</div><div class="line">        mPrivateFlags |= PFLAG_OPAQUE_BACKGROUND;</div><div class="line">    &#125; else &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_OPAQUE_BACKGROUND;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final int flags = mViewFlags;</div><div class="line">    //若没有横竖滚动条，或者滚动条是OVERLAY类型的，则打上PFLAG_OPAQUE_SCROLLBARS标识</div><div class="line">    if (((flags &amp; SCROLLBARS_VERTICAL) == 0 &amp;&amp; (flags &amp; SCROLLBARS_HORIZONTAL) == 0) ||</div><div class="line">                (flags &amp; SCROLLBARS_STYLE_MASK) == SCROLLBARS_INSIDE_OVERLAY ||</div><div class="line">                (flags &amp; SCROLLBARS_STYLE_MASK) == SCROLLBARS_OUTSIDE_OVERLAY) &#123;</div><div class="line">        mPrivateFlags |= PFLAG_OPAQUE_SCROLLBARS;</div><div class="line">    &#125; else &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_OPAQUE_SCROLLBARS;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ViewGroup 默认情况下(<code>initViewGroup()</code>)会被设置成<code>WILL_NOT_DRAW</code>,会在<code>setFlags()</code>设置了<code>SKIP_DRAW</code>.这样会导致在<code>draw(三个参数)</code>中跳过 <code>draw(canva)</code></li>
<li>ViewGroup 调用了<code>draw(canvas)</code>还不一定执行<code>onDraw(canvas)</code>,因为会判断<code>PFLAG_DIRTY_OPAQUE</code>,<strong>没有设置这个标志位<code>onDraw</code>才会被调用</strong>. 对于这个 FLAG,是在<code>ViewGroup.invalidateChild()</code>中设置的(这个方法被调用的的实质是<strong>我们调用了 View.invalidate()</strong>),他会将他的<strong>父ViewGroup</strong>设置<code>PFLAG_DIRTY_OPAQUE</code>,这样父ViewGroup 在 invalidate 就不会重复绘制一次了.</li>
<li>如果我们想调用 onDraw,可以通过以下方法<ul>
<li>为 ViewGroup 设置背景色</li>
<li>手动 <code>setWillNotDraw(false)</code>，去掉其<code>WILL_NOT_DRAW</code> flag。</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/litefish/article/details/52859300" target="_blank" rel="external">从源码看invalidate和requestLayout的区别</a></li>
<li><a href="https://juejin.im/post/59dae74af265da065755092a" target="_blank" rel="external">你真的了解Android ViewGroup的draw和onDraw的调用时机吗</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/29/Android-非UI线程能更新UI吗/" itemprop="url">
                  Android 非UI线程能更新UI吗
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-29T00:01:57+08:00" content="2018-03-29">
              2018-03-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/29/Android-非UI线程能更新UI吗/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/29/Android-非UI线程能更新UI吗/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/29/Android-非UI线程能更新UI吗/" class="leancloud_visitors" data-flag-title="Android 非UI线程能更新UI吗">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道 Android 非UI线程 不能更新UI,否则会抛异常 <code>CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</code>,我们来了解为什么</p>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><blockquote>
<p>采用一个专门的线程从队列中抽取事件，并把他们转发给应用程序定义的事件处理器</p>
</blockquote>
<p>其实也有人视图多线程的GUI,但是由于竞争条件和死锁导致的稳定性问题等,不得不放弃,否则多线程同时操作GUI会线程同步的问题.</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="更新UI的方法"><a href="#更新UI的方法" class="headerlink" title="更新UI的方法"></a>更新UI的方法</h3><ul>
<li>requestLayout()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-------View.requelayout()-----</div><div class="line">public void requestLayout() &#123;</div><div class="line">    ...</div><div class="line">    if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;</div><div class="line">            mParent.requestLayout();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>View调用requestLayout,会一直调用其父类的<code>ViewParent.requestlayout</code>,而我们的<code>ViewRootImpl</code>就是实现了<code>ViewParent</code>的类,我们在分析 View 绘制流程的时候也分析过 ViewRoot,他是View绘制的开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">-------------ViewRootImpl.requestlayout()---------</div><div class="line"> @Override</div><div class="line">    public void requestLayout() &#123;</div><div class="line">        if (!mHandlingLayoutInLayoutRequest) &#123;</div><div class="line">            checkThread();</div><div class="line">            mLayoutRequested = true;</div><div class="line">            scheduleTraversals();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">-----------------ViewRootImpl.checkThread-----------</div><div class="line">void checkThread() &#123;</div><div class="line">        if (mThread != Thread.currentThread()) &#123;</div><div class="line">            throw new CalledFromWrongThreadException(</div><div class="line">                    &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>终于找到了,原来是<code>ViewRootImpl</code>手动检查了操作线程</p>
<ul>
<li>invalidate()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">-------------View.invalidate()-----------</div><div class="line"></div><div class="line">public void invalidate() &#123;</div><div class="line">        invalidate(true);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"> public void invalidate(boolean invalidateCache) &#123;</div><div class="line">        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,</div><div class="line">            boolean fullInvalidate) &#123;</div><div class="line">    ...   </div><div class="line">    if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class="line">                final Rect damage = ai.mTmpInvalRect;</div><div class="line">                damage.set(l, t, r, b);</div><div class="line">               //重点,一直调用父类的 invalidate p.invalidateChild(this, damage);</div><div class="line">            &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到,View的<code>invalidate</code>也是一直调用其父类VewGroup的<code>invalidateChild()</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">--------------ViewGroup.invalidateChild()-------------</div><div class="line"></div><div class="line"> public final void invalidateChild(View child, final Rect dirty) &#123;</div><div class="line">     ...</div><div class="line">     ViewParent parent = this;</div><div class="line">     ...</div><div class="line">     parent = parent.invalidateChildInParent(location, dirty);</div><div class="line">     ...</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>最终,ViewGroup会调用<code>ViewRootImpl</code>的<code>invalidateChildInParent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123;</div><div class="line">        checkThread();</div><div class="line">        if (DEBUG_DRAW) Log.v(mTag, &quot;Invalidate child: &quot; + dirty);</div><div class="line"></div><div class="line">        if (dirty == null) &#123;</div><div class="line">            invalidate();</div><div class="line">            return null;</div><div class="line">        &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mCurScrollY != 0 || mTranslator != null) &#123;</div><div class="line">            mTempRect.set(dirty);</div><div class="line">            dirty = mTempRect;</div><div class="line">            if (mCurScrollY != 0) &#123;</div><div class="line">                dirty.offset(0, -mCurScrollY);</div><div class="line">            &#125;</div><div class="line">            if (mTranslator != null) &#123;</div><div class="line">                mTranslator.translateRectInAppWindowToScreen(dirty);</div><div class="line">            &#125;</div><div class="line">            if (mAttachInfo.mScalingRequired) &#123;</div><div class="line">                dirty.inset(-1, -1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        invalidateRectOnScreen(dirty);</div><div class="line"></div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到, <code>invalidate()</code>最终方法也是手动调用了<code>checkThread()</code>检查操作UI的线程</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>既然规定 UI线程才能操作 UI 是在 <code>ViewRootImpl</code> 检查的,那么我们只需要在创建<code>ViewRootImpl</code>之前非UI线程修改UI就行了,通过我们上次的文章<code>Activiy Window DecorView的关系</code>得知,<strong>ViewRootImpl是在 onResume()回调后创建的</strong>,所以我们在这之前更新UI是不需要在UI线程的.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/23/Retrofit-源码分析/" itemprop="url">
                  Retrofit 源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-23T23:30:56+08:00" content="2018-03-23">
              2018-03-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/23/Retrofit-源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/23/Retrofit-源码分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/23/Retrofit-源码分析/" class="leancloud_visitors" data-flag-title="Retrofit 源码分析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>创建 API 接口类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface GankApi &#123;</div><div class="line">    String host = &quot;http://gank.io/api/data/&quot;;</div><div class="line">    @GET(&quot;Android/10/&#123;page&#125;&quot;)</div><div class="line">    Call&lt;Android&gt; getAndroid(@Path(&quot;page&quot;) int page);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>创建 Retrofit 实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 创建 Retrofit 实例</div><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">    .baseUrl(GankApi.host)</div><div class="line">    //添加Gson解析</div><div class="line">    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">    .build();</div><div class="line">    </div><div class="line">//生成接口实现类</div><div class="line">GankApi gankApi = retrofit.create(GankApi.class);</div><div class="line"></div><div class="line">//调用接口定义的请求方法,返回请求结果 call</div><div class="line">Call&lt;Android&gt; call = gankApi.getAndroid(1);</div><div class="line"></div><div class="line">//调用 call 对象的 enqueue 方法,执行异步请求</div><div class="line">call.enqueue(Callback callback);</div></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Retrofit-Builder"><a href="#Retrofit-Builder" class="headerlink" title="Retrofit.Builder()"></a>Retrofit.Builder()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//运行平台</div><div class="line">private final Platform platform;</div><div class="line">//callFactory,Http请求,只有一个</div><div class="line">private @Nullable okhttp3.Call.Factory callFactory;</div><div class="line">private HttpUrl baseUrl;</div><div class="line">//一系列结果转换器,将服务器数据(JSON,XML等)转成任意类型,有很多个</div><div class="line">private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();</div><div class="line">//适配器,把请求结果 retrofit2.call&lt;T&gt; 转为 T</div><div class="line">private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();</div><div class="line">//执行的线程池</div><div class="line">private @Nullable Executor callbackExecutor;</div><div class="line"></div><div class="line">public Builder() &#123;</div><div class="line">  this(Platform.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到, Builder() 传入了我们的 Platform</p>
<h4 id="Retrofit-Platform"><a href="#Retrofit-Platform" class="headerlink" title="Retrofit.Platform"></a>Retrofit.Platform</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static class Android extends Platform &#123;</div><div class="line">  @Override public Executor defaultCallbackExecutor() &#123;</div><div class="line">    return new MainThreadExecutor();</div><div class="line">  &#125;</div><div class="line">  @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123;</div><div class="line">    return new ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">  &#125;</div><div class="line">  static class MainThreadExecutor implements Executor &#123;</div><div class="line">    private final Handler handler = new Handler(Looper.getMainLooper());</div><div class="line">    @Override public void execute(Runnable r) &#123;</div><div class="line">      handler.post(r);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在 Android 中,我们的 <code>CallAdapterFactory</code>使用的是<code>ExecutorCallAdapterFactory()</code></li>
<li>在 Android 中,我们的 <code>Executor</code>使用的 <code>MainHandlerr</code>,默认Callback主线程</li>
</ul>
<h3 id="Retrofit-Builder-build"><a href="#Retrofit-Builder-build" class="headerlink" title="Retrofit.Builder().build()"></a>Retrofit.Builder().build()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public Retrofit build() &#123;</div><div class="line">      ...</div><div class="line">      //没有额外配置,默认 OkHttpClient</div><div class="line">      okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">      if (callFactory == null) &#123;</div><div class="line">        callFactory = new OkHttpClient();</div><div class="line">      &#125;</div><div class="line">        //没有额外配置,默认给 defaultCallbackExecutor</div><div class="line">        //而我们前面分析 Platform 得知,返回的是 Android.MainExecutor(MainHandler)</div><div class="line">      Executor callbackExecutor = this.callbackExecutor;</div><div class="line">      if (callbackExecutor == null) &#123;</div><div class="line">        callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      //设置 CallAdapterFactory,由Platform 分析,添加的是 Android.ExecutorCallAdapterFactory</div><div class="line">      List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);</div><div class="line">      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line"></div><div class="line">      //设置 responseConverter</div><div class="line">      List&lt;Converter.Factory&gt; converterFactories =</div><div class="line">          new ArrayList&lt;&gt;(1 + this.converterFactories.size());</div><div class="line"></div><div class="line">      converterFactories.add(new BuiltInConverters());</div><div class="line">      converterFactories.addAll(this.converterFactories);</div><div class="line">      //创建对象</div><div class="line">      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</div><div class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由于我们 <code>Builder()</code>构造函数默认只传入了 Plarform,所以其他参数都是 null, build()方法就会进行一些初始化操作</p>
<ul>
<li><code>CallFactory</code>使用 <code>OkHttpClient</code></li>
<li><code>CallAdapterFactory</code>使用 <code>Android.ExecutorCallAdapterFactory</code></li>
<li><code>Executor</code>使用的是 <code>MainExecutor(MainHandler)</code>,calllback 运行在主线程上</li>
</ul>
<h3 id="动态代理生成对应的API实例"><a href="#动态代理生成对应的API实例" class="headerlink" title="动态代理生成对应的API实例"></a>动态代理生成对应的API实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        new InvocationHandler() &#123;</div><div class="line">            ...</div><div class="line">            //生成对应的请求方法</div><div class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">            //将请求方法封装成 OkHttpCall,方便利用`OkHttp`进行网络请求</div><div class="line">            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            //将封装好的 call 返回,这样我们就能调用对应 API 实例进行同步或者异步请求了</div><div class="line">            return serviceMethod.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>重点就是上面三行代码</p>
<h3 id="ServiceMethod-loadServiceMethod"><a href="#ServiceMethod-loadServiceMethod" class="headerlink" title="ServiceMethod  loadServiceMethod()"></a>ServiceMethod  loadServiceMethod()</h3><blockquote>
<p>ServiceMethod 用于将接口,转为一次 HTTP 调用</p>
</blockquote>
<p>Retrofit 用一个双链表缓存方法<br><code>private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;();</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ServiceMethod loadServiceMethod(Method method) &#123;</div><div class="line">  ServiceMethod result;</div><div class="line">  synchronized (serviceMethodCache) &#123;</div><div class="line">      // 从缓存中获取该方法</div><div class="line">    result = serviceMethodCache.get(method);</div><div class="line">    if (result == null) &#123;</div><div class="line">        // 没有就进行创建并且存入链表缓存</div><div class="line">      result = new ServiceMethod.Builder(this, method).build();</div><div class="line">      serviceMethodCache.put(method, result);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ServiceMethod-Builder-this-method-build"><a href="#ServiceMethod-Builder-this-method-build" class="headerlink" title="ServiceMethod.Builder(this, method).build()"></a>ServiceMethod.Builder(this, method).build()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-----Builder()------</div><div class="line">Builder(Retrofit retrofit, Method method) &#123;</div><div class="line">      this.retrofit = retrofit;</div><div class="line">      this.method = method;</div><div class="line">      this.methodAnnotations = method.getAnnotations();</div><div class="line">      this.parameterTypes = method.getGenericParameterTypes();</div><div class="line">      this.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">初始化了一些参数</div></pre></td></tr></table></figure>
<ul>
<li><code>callFactory</code>,负责创建 HTTP 请求,Http 请求被抽象成了 <code>OKhttp.Call</code>,表示一个可以随时被执行的HTTP请求</li>
<li><code>callAdapter</code>,结果转换器,将<code>retrofit2.Call&lt;T&gt;</code>转为<code>T</code>,这个过程会执行HTTP请求,拿到服务器返回的数据,并且将数据转为<code>T</code>,通过<code>Converter&lt;F,T&gt;</code>实现的</li>
<li><code>responseConverter</code>,<code>Converter&lt;F,T&gt;</code>类型.把服务器数据(JSON.XML,Protoc等)转为<code>T</code></li>
<li><code>parameterHandlers</code>,负责解析API定义的每个方法的参数,采用运行时注解,并且在构造HTTP请求时设置相应参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">------loadServiceMethod()--------</div><div class="line">ServiceMethodCache 实现了缓存</div><div class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</div><div class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</div><div class="line">    if (result != null) return result;</div><div class="line"></div><div class="line">    synchronized (serviceMethodCache) &#123;</div><div class="line">      result = serviceMethodCache.get(method);</div><div class="line">      if (result == null) &#123;</div><div class="line">        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</div><div class="line">        serviceMethodCache.put(method, result);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">  &#125;</div><div class="line">---------------build()------------</div><div class="line">public ServiceMethod build() &#123;</div><div class="line">    //创建 callAdapter</div><div class="line">    callAdapter = createCallAdapter();</div><div class="line">    ...</div><div class="line">    //创建结果转换器</div><div class="line">    responseConverter = createResponseConverter();</div><div class="line">    ...</div><div class="line">    //解析我们的API接口注解,是 @Retention(RUNTIME) 运行时注解</div><div class="line">    for (Annotation annotation : methodAnnotations) &#123;</div><div class="line">        parseMethodAnnotation(annotation);</div><div class="line">      &#125;</div><div class="line">     ...</div><div class="line">     return Call;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="callFactory"><a href="#callFactory" class="headerlink" title="callFactory"></a>callFactory</h4><p>由 Retrofit 提供,我们前面分析过了 CallFactory 的创建 . 我们在构造 Retrofit 对象的时候可以指定 <code>callFactory</code>,(比如 <code>HttpURLConnection</code>,<code>OkHttp</code>),如果不指定,默认设置<code>okHttp.OkHttpClient</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">--------Retrofit 的 builld()方法------</div><div class="line">okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">      if (callFactory == null) &#123;</div><div class="line">        callFactory = new OkHttpClient();</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h4 id="callAdapter"><a href="#callAdapter" class="headerlink" title="callAdapter"></a>callAdapter</h4><p>由 Retrofit 提供,我们前面分析过了 callAdapter的创建,默认 Android 平台是 <code>ExecutorCallAdapterFactory</code>,对应 <code>Executor</code>是<code>MainExecutor(MainLooper)</code>.<code>createCallAdapter</code>最终会调用<code>nextCallAdapter()</code>,遍历所有的 <code>CallAdapter.Factory</code>,拿到自己想要的 callAdapter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">    Executor callbackExecutor = this.callbackExecutor;</div><div class="line">      if (callbackExecutor == null) &#123;</div><div class="line">      //返回 Android.MainThreadExecutor()</div><div class="line">        callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">      &#125;</div><div class="line">      //返回 Android.ExecutorCallAdapterFactory</div><div class="line">      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="responseConverter"><a href="#responseConverter" class="headerlink" title="responseConverter"></a>responseConverter</h4><p>由 Retrofit 提供,逻辑与 <code>callAdapter</code>一致,遍历<code>Converter.Factory</code>,拿到自己想要的 responseConverter,用于将服务器的 <code>Response</code>(也就是 callFactory请求到的<code>Response</code>)转为自己的<code>ResponseBody</code></p>
<h4 id="parameterHandlers"><a href="#parameterHandlers" class="headerlink" title="parameterHandlers"></a>parameterHandlers</h4><p>解析 API 接口的注解类型(比如<code>Path</code>,<code>Query</code>,<code>Field</code>),利用<code>Retrofit.StringConverter</code>将传递的参数转为String,而 <code>@Body</code> 和 <code>@Part</code> 类型的参数则利用 requestBodyConverter 进行转换。</p>
<h3 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h3><blockquote>
<p>利用 serviceMethod 信息,创建对应的 okhttpCall,用于http 请求</p>
</blockquote>
<p>我们使用 <code>execute()</code> 同步或者 <code>enqueue(Callback)</code>异步 进行网络请求.我们直接分析 <code>enqueue(Callback)</code></p>
<h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue()"></a>enqueue()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">    checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line"></div><div class="line">    okhttp3.Call call;</div><div class="line">    Throwable failure;</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line">      ...</div><div class="line">      //创建 Call 对象,后面分析就是 okhttp.call</div><div class="line">      call = rawCall = createRawCall();</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    //进行异步请求,这个 call 是 </div><div class="line">    call.enqueue(new okhttp3.Callback() &#123;</div><div class="line">      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123;</div><div class="line">        Response&lt;T&gt; response;</div><div class="line">        try &#123;</div><div class="line">        //将okhttp.Response 结果转为自己的 Response</div><div class="line">          response = parseResponse(rawResponse);</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">          callFailure(e);</div><div class="line">          return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">        //成功回调</div><div class="line">          callback.onResponse(OkHttpCall.this, response);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      ...</div><div class="line">        //失败的回调</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">       ...</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  --------------createRawCall()--------------</div><div class="line">  </div><div class="line">  private okhttp3.Call createRawCall() throws IOException &#123;</div><div class="line">  //利用 serviceMethod.toCall(args) 创建 okhttp3.Request</div><div class="line">  ///利用到了 parameterHandlers</div><div class="line">  ///函数最后调用了 serviceMethod.callFactory.newCall(request) </div><div class="line">  ///默认是 OkHttpClient</div><div class="line">  okhttp3.Call call = serviceMethod.toCall(args);</div><div class="line">  ...</div><div class="line">  return call;</div><div class="line">&#125;</div><div class="line"></div><div class="line">--------------------parseResponse()------------</div><div class="line"></div><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</div><div class="line">  ResponseBody rawBody = rawResponse.body();</div><div class="line"></div><div class="line">  // Remove the body&apos;s source (the only stateful object) so we can pass the response along.</div><div class="line">  rawResponse = rawResponse.newBuilder()</div><div class="line">      .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</div><div class="line">      .build();</div><div class="line"></div><div class="line">  int code = rawResponse.code();</div><div class="line">  if (code &lt; 200 || code &gt;= 300) &#123;</div><div class="line">    // ...返回错误</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (code == 204 || code == 205) &#123;</div><div class="line">    return Response.success(null, rawResponse);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);</div><div class="line">  try &#123;</div><div class="line">  //转换结果,利用到了我们前面准备好的 responseConverter</div><div class="line">    T body = serviceMethod.toResponse(catchingBody);</div><div class="line">    return Response.success(body, rawResponse);</div><div class="line">  &#125; catch (RuntimeException e) &#123;</div><div class="line">    // ...异常处理</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>这个主要包括三个步骤,具体的</p>
<ul>
<li>创建 <code>OKhttp.call</code><blockquote>
<p>利用 <code>serviceMethod.toCall(args)</code> 创建 okhttp3.Request<br>利用到了 parameterHandlers.<code>toCall</code>函数最后调用了 <code>serviceMethod.callFactory.newCall(request)</code>,默认是 OkHttpClient,也可以指定其他(比如 HtppURLConnection)</p>
</blockquote>
</li>
<li>执行网络请求  (call.execute())</li>
<li>解析网络请求返回的数据  (parseResponse)</li>
</ul>
<h3 id="serviceMethod-adapt-okHttpCall"><a href="#serviceMethod-adapt-okHttpCall" class="headerlink" title="serviceMethod.adapt(okHttpCall)"></a>serviceMethod.adapt(okHttpCall)</h3><p>该方法调用 <code>callAdapter.adapt(okHttpCall)</code>,由前面分析的 <code>Retrofit.Platform</code>我们知道,调用的是 <code>ExecutorCallAdapterFactory</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">-----------------ExecutorCallAdapterFactory.adapt------</div><div class="line">@Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">        return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">-----------------------ExecutorCallbackCall-----------------------</div><div class="line"></div><div class="line">static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</div><div class="line">  final Executor callbackExecutor;</div><div class="line">  final Call&lt;T&gt; delegate;</div><div class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">    this.callbackExecutor = callbackExecutor;</div><div class="line">    this.delegate = delegate;</div><div class="line">  &#125;</div><div class="line">  @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">    if (callback == null) throw new NullPointerException(&quot;callback == null&quot;);</div><div class="line">    delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">      @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">        callbackExecutor.execute(new Runnable() &#123;</div><div class="line">          @Override public void run() &#123;</div><div class="line">            if (delegate.isCanceled()) &#123;</div><div class="line">              callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">            &#125; else &#123;</div><div class="line">              callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">      // 省略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>adapt(call)</code>传入的是<code>okhttp.call</code>,所以 <code>ExecutorCallbackCall.delegete</code>也是 <code>okhttp.call</code>,而<code>callbackExecutor</code>我们在<code>Retrofit.Platform</code>前面分析了,是<code>Handler(MainLooper)</code></p>
<p>这样一来,<strong>我们直接调用了 okhttp.call.enqueue(),在回调方法中, callbackExecutor.execute(new Runnable() {….},利用的是<code>mainHandler.post()</code></strong>,这样就完成了子线程切换到 主线程的工作</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="源码整体流程"><a href="#源码整体流程" class="headerlink" title="源码整体流程"></a>源码整体流程</h4><p><code>GankApi gankApi = retrofit.create(GankApi.class);</code> –&gt;</p>
<p><code>return (T) Proxy.newProxyInstance（...）{...}</code>—-&gt;</p>
<p><code>Call&lt;Android&gt; call = gankApi.getAndroid(1);</code> —-&gt;</p>
<p><code>public Object invoke(...){...} 调用代理类的invoke()。</code></p>
<p>而在代理类中,<code>ServiceMethod</code>创建了对应的API方法,构建HTTP请求需要的参数等信息</p>
<p><code>OkHttpCall</code>利用<code>ServiceMethod</code>创建了对应的<code>okhttp.call</code></p>
<p>最后 <code>ServiceMethod.callAdapter.adapt(okhttpCall)</code>调用对应CalAdapter,然后我们执行<code>enqueue()或者execute()</code>,就是执行<code>okhttpCall</code>对应的方法,完成了HTTP请求.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit</a></li>
<li><a href="http://imxie.itscoder.com/2016/08/20/retrofit-source-learning/" target="_blank" rel="external">框架源码 — 简析学习 Retrofit</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/15/一个Activity从启动到显示内容都发生了什么/" itemprop="url">
                  一个Activity从启动到显示内容都发生了什么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-15T13:47:34+08:00" content="2018-03-15">
              2018-03-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/15/一个Activity从启动到显示内容都发生了什么/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/15/一个Activity从启动到显示内容都发生了什么/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/15/一个Activity从启动到显示内容都发生了什么/" class="leancloud_visitors" data-flag-title="一个Activity从启动到显示内容都发生了什么">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="涉及到的几个类"><a href="#涉及到的几个类" class="headerlink" title="涉及到的几个类"></a>涉及到的几个类</h2><ul>
<li><strong>zygote</strong>:开启App新进程,都是通过 <code>zygote的fork</code> 实现的</li>
<li><strong>ActivityManagerService</strong>:管理Activity 的生命周期的服务端</li>
<li><strong>Instrumentation</strong>: 对Application和Activity 初始化以及生命周期管理的工具类</li>
<li><strong>ActivityThread</strong>:与<code>AMS</code>交互的类,程序入口</li>
<li><strong>ActivityStack</strong>:Activity的栈管理类</li>
<li><strong>ActivityStackSupurvior</strong>:管理<code>ActivityStack</code>的类</li>
</ul>
<h2 id="1-开始请求执行启动Actiivty"><a href="#1-开始请求执行启动Actiivty" class="headerlink" title="1.开始请求执行启动Actiivty"></a>1.开始请求执行启动Actiivty</h2><p>一般来说,我们启动Activity是从<code>Launcher</code>启动的,这个时候还需要通过 <code>Zygote fork</code>一个新进程.我们知道,启动 <code>Activity</code>需要通过<code>Binder</code>机制跨进程来告诉服务端<code>ActivityManagerService</code>启动一个<code>Activity</code></p>
<h3 id="一般来说在Client端有如下步骤"><a href="#一般来说在Client端有如下步骤" class="headerlink" title="一般来说在Client端有如下步骤"></a>一般来说在<code>Client端</code>有如下步骤</h3><ul>
<li><strong>MyActivity</strong>.startActivity()</li>
<li><strong>Activity</strong>.startActivity()</li>
<li><strong>Activity</strong>.startActivityFroResult() <ul>
<li><code>层层调用,最后执行这个方法,如果 requestCode &lt; 0,那么启动 Activity 将不会有 result 返回</code></li>
</ul>
</li>
<li><strong>Instumentation</strong>.execStartActivity<ul>
<li><code>Instrumentation</code>是 Activity 的<code>Client端</code>的实际操作类</li>
</ul>
</li>
<li><strong>ActivityManager</strong>.getService().startActivity()<ul>
<li>getService() : <code>IActivityManager.Stub.asInterface(b)</code></li>
<li><code>ActivityManagerService</code>继承自<code>IActivityManager</code>,getService()会在<code>Client端</code>返回一个 <code>ActivityManagerProxy</code>对象,API26采用了<code>AIDL</code>的方式</li>
</ul>
</li>
</ul>
<blockquote>
<p>到目前为止,Activity 启动流程已经从 <code>Client端</code>转移到了<code>Server端了</code></p>
</blockquote>
<h2 id="2-ActivityManagerService-启动-Activity"><a href="#2-ActivityManagerService-启动-Activity" class="headerlink" title="2.ActivityManagerService 启动 Activity"></a>2.ActivityManagerService 启动 Activity</h2><h3 id="Server-端有如下步骤"><a href="#Server-端有如下步骤" class="headerlink" title="Server 端有如下步骤"></a><code>Server 端</code>有如下步骤</h3><ul>
<li>ActivityManagerService.startActivity()</li>
<li>ActivityManagerService.startActivityAsUser()</li>
<li><code>ActivityStarter</code>.startActivityMayWait()</li>
<li><code>ActivityStarter</code>.startActivityLocked()</li>
<li><code>ActivityStarter</code>.startActivity()</li>
<li><code>ActivityStarter</code>.startActivityUnchecked()</li>
<li><code>ActivityStackSupervisor</code>.resumeFocusedStackTopActivityLocked()</li>
<li><code>ActivityStack</code>.resumeTopActivityUncheckedLocked()</li>
<li><p><code>ActivityStack</code>.resumeTopActivityInnerLocked()</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    if (mResumedActivity != null) &#123;</div><div class="line">        if (DEBUG_STATES) Slog.d(TAG_STATES,</div><div class="line">                &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</div><div class="line">        pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);</div><div class="line">    &#125;        ...</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>经过一系列调用,最终调用了 <code>startPausingLocked()</code>,该方法作用就是让系统栈的Activity执行 <code>onPause</code></p>
</blockquote>
<h2 id="3-栈顶-Activity-的-onPause-方法"><a href="#3-栈顶-Activity-的-onPause-方法" class="headerlink" title="3.栈顶 Activity 的 onPause 方法"></a>3.栈顶 Activity 的 onPause 方法</h2><h3 id="启动新-Activity-之前栈顶的-Activity-onPause-主要下面几个步骤"><a href="#启动新-Activity-之前栈顶的-Activity-onPause-主要下面几个步骤" class="headerlink" title="启动新 Activity ,之前栈顶的 Activity onPause 主要下面几个步骤"></a>启动新 Activity ,之前栈顶的 Activity onPause 主要下面几个步骤</h3><ul>
<li><code>ActivityStack</code>.startPausingLocked()</li>
<li><code>ApplicationThread</code>.schedulePauseActivity()</li>
<li><code>ActivityThread.H</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.handleMessage()</li>
<li><code>ActivityThread</code>.handlePauseActivity()<ul>
<li>这个方法会让 栈顶Activity 先 <code>onPuase</code>,然后<code>启动 新Activity</code></li>
</ul>
</li>
<li><code>ActivityThread</code>.performPauseActivity()</li>
<li><code>ActivityThread</code>.performPauseActivityIfNeeded()</li>
<li><code>Instrumentation</code>.callActivityOnPause()</li>
<li><code>Activity</code>.performPause()</li>
<li><code>Activity</code>.onPause()</li>
</ul>
<blockquote>
<p>在这一步,栈顶的 Activity 已经执行了 <code>onPause</code> 方法,此时返回  (3)步骤 的 <code>handlePauseActivity()</code> ,方法最后执行了 <code>ActivityManager.getService().activityPaused(token);</code> 来告诉 AMS “栈顶Activity 已经” <strong>onPuase()</strong>了, Binder 跨进程调用</p>
</blockquote>
<ul>
<li><code>ActivityManager</code>.getService().activityPaused(token);</li>
<li><code>ActivityStack</code>.activityPausedLocked()</li>
<li><code>ActivityStack</code>.completePauseLocked()</li>
<li><code>ActivityStackSupervisor</code>.resumeFocusedStackTopActivityLocked()</li>
<li><code>ActivityStack</code>.resumeTopActivityUncheckedLocked()</li>
<li><code>ActivityStack</code>.resumeTopActivityInnerLocked()</li>
<li><code>ActivityStackSupervisor</code>.resumeTopActivityInnerLocked()</li>
<li><code>ActivityStackSupervisor</code>.startSpecificActivityLocked()</li>
</ul>
<blockquote>
<p><code>startSpecificActivityLocked</code> 会判断启动的 Activity 是否已经启动,启动的话直接调用 <code>realStartActivityLocked</code>.  否则调用 <code>startProcessLocked()</code>,启动应用进程</p>
</blockquote>
<h2 id="4-启动Activity所属的应用进程"><a href="#4-启动Activity所属的应用进程" class="headerlink" title="4.启动Activity所属的应用进程"></a>4.启动Activity所属的应用进程</h2><p>涉及 <code>zygote</code>启动的源码暂时不分析了,我们知道 <code>Zygote</code>通过<code>Socket</code>方式让<code>Zygote fork</code>出一个新进程,然后根据<code>android.app.ActivityThread</code>字符串,反射出对象并且调用<code>main()</code>方法,这样我们的进程已经启动了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        ...</div><div class="line">        Looper.prepareMainLooper();</div><div class="line"></div><div class="line">        ActivityThread thread = new ActivityThread();</div><div class="line">        thread.attach(false);</div><div class="line">        ...</div><div class="line">        Looper.loop();</div><div class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到, <code>ActivityThread 的 main</code> 方法初始化并且启动了一个 <code>loop</code>,并且执行了自己的 <code>attch</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private void attach(boolean system) &#123;</div><div class="line">    ...</div><div class="line">    final IActivityManager mgr = ActivityManager.getService();</div><div class="line">    try &#123;</div><div class="line">        mgr.attachApplication(mAppThread);</div><div class="line">    &#125; catch (RemoteException ex) &#123;</div><div class="line">        throw ex.rethrowFromSystemServer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法通过<code>Binder</code>调用了<code>ActivityManagerService</code>的<code>attachApplication</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</div><div class="line">            int pid) &#123;</div><div class="line">        ...</div><div class="line">        if (normalMode) &#123;</div><div class="line">            try &#123;</div><div class="line">                if (mStackSupervisor.attachApplicationLocked(app)) &#123;</div><div class="line">                    didSomething = true;</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在 <code>attachApplicationLocked(app)</code>中,启动了应用进程,并且开始 Activity 的启动</p>
<h2 id="5-启动-Activity"><a href="#5-启动-Activity" class="headerlink" title="5.启动 Activity"></a>5.启动 Activity</h2><h3 id="从启动了对应-应用进程-到启动-Activity-主要包括以下几个步骤"><a href="#从启动了对应-应用进程-到启动-Activity-主要包括以下几个步骤" class="headerlink" title="从启动了对应 应用进程,到启动 Activity,主要包括以下几个步骤"></a>从启动了对应 应用进程,到启动 Activity,主要包括以下几个步骤</h3><ul>
<li><code>ActivityStackSupervisor</code>.attachApplicationLocked()</li>
<li><code>ActivityStackSupervisor</code>.realStartActivityLocked()</li>
<li><code>ApplicationThread</code>.scheduleLaunchActivity()</li>
<li><code>ActivityThread</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.handleMessage()</li>
<li><code>ActivityThread</code>.handleLauncherActivity()</li>
<li><code>ActivityThread</code>.performLauncherActivity()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line">       //从 ActivityClientRecord 获取 Activity的组件信息</div><div class="line">       ActivityInfo aInfo = r.activityInfo;</div><div class="line">       if (r.packageInfo == null) &#123;</div><div class="line">           r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</div><div class="line">                   Context.CONTEXT_INCLUDE_CODE);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ComponentName component = r.intent.getComponent();</div><div class="line">       if (component == null) &#123;</div><div class="line">           component = r.intent.resolveActivity(</div><div class="line">               mInitialApplication.getPackageManager());</div><div class="line">           r.intent.setComponent(component);</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       //通过 Instrumentation 的 newActivity 使用类加载器创建 Activity 对象</div><div class="line">       if (r.activityInfo.targetActivity != null) &#123;</div><div class="line">           component = new ComponentName(r.activityInfo.packageName,</div><div class="line">                   r.activityInfo.targetActivity);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ContextImpl appContext = createBaseContextForActivity(r);</div><div class="line">       Activity activity = null;</div><div class="line">       try &#123;</div><div class="line">           java.lang.ClassLoader cl = appContext.getClassLoader();</div><div class="line">           activity = mInstrumentation.newActivity(</div><div class="line">                   cl, component.getClassName(), r.intent);</div><div class="line">          &#125;</div><div class="line">       ...</div><div class="line">       //通过 LoadedApk 的 makeApplication 创建 Application 对象</div><div class="line">       //在 makeApplication 中,通过 Instrumentation 的 callApplicationOnCreate 来调用 onCreate 方法</div><div class="line">       try &#123;</div><div class="line">           Application app = r.packageInfo.makeApplication(false, mInstrumentation);</div><div class="line"></div><div class="line">           if (activity != null) &#123;</div><div class="line">              ...</div><div class="line">              //调用 activity 的 attach 方法</div><div class="line">              //在 attach 方法中,ContextImpl会与Activity 建立联系</div><div class="line">              //attch 方法中,也会初始化Windows,将自己与Windows建立联系</div><div class="line">               activity.attach(appContext, this, getInstrumentation(), r.token,</div><div class="line">                       r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                       r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                       r.referrer, r.voiceInteractor, window, r.configCallback);</div><div class="line">               ...</div><div class="line">               //调用 callActivityOnCreate,最终调用了 onCreate</div><div class="line">               if (r.isPersistable()) &#123;</div><div class="line">                   mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">               &#125; else &#123;</div><div class="line">                   mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">               &#125;</div><div class="line">               ...</div><div class="line">               if (!r.activity.mFinished) &#123;</div><div class="line">               //调用 performStart,最终是调用 onStart</div><div class="line">                   activity.performStart();</div><div class="line">                   r.stopped = false;</div><div class="line">               &#125;</div><div class="line">               ...</div><div class="line">       return activity;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Instrumentation</code>.callActivityOnCreate()</li>
<li><code>Activity</code>.onCreate()</li>
<li><code>Activity</code>.performStart()</li>
<li><code>Activity</code>.onStart()</li>
<li><code>Instrumentation</code>.callActivityOnStart()</li>
<li><code>Activity</code>.onStart()</li>
<li>回到:<code>ActivityThread</code>.performLauncherActivity() -&gt; 继续执行<code>ActivityThread</code>.handleResumeActivity()</li>
<li><code>ActivityThread</code>.performResumeActivity()</li>
<li><code>Activity</code>.performResume()</li>
<li><code>Instrumentation</code>.callActivityOnResume()</li>
<li><code>Activity</code>.onResume()</li>
<li>回到: <code>ActivityThread</code>.handleResumeActivity(),继续执行 <code>ActivityManager</code>.getService().activityResumed(token);</li>
</ul>
<blockquote>
<p>到这一步,利用<code>Binder</code>通知<code>ActivityManagerService</code>当前 Activity 已经<code>onResume()</code>了,接下来要做的就是之前栈顶的Activity <code>onStop</code></p>
</blockquote>
<h2 id="之前栈顶Activity的onStop"><a href="#之前栈顶Activity的onStop" class="headerlink" title="之前栈顶Activity的onStop"></a>之前栈顶Activity的onStop</h2><h3 id="之前的栈顶Activity执行-onStop-主要有下面几个步骤"><a href="#之前的栈顶Activity执行-onStop-主要有下面几个步骤" class="headerlink" title="之前的栈顶Activity执行 onStop 主要有下面几个步骤"></a>之前的栈顶Activity执行 onStop 主要有下面几个步骤</h3><ul>
<li><code>ActivityThread</code>.handleResumeActivity()</li>
<li>Looper.myQueue().addIdleHandler(new Idler());</li>
<li>在 <code>Idler</code>方法内部,执行了 <code>ActivityManager</code>.getService().activityIdle()</li>
<li><code>ActivityStackSupervisor</code>.activityIdleInternalLocked() </li>
<li><code>ActivityStack</code>.stopActivityLocked()</li>
<li><code>ApplicationThread</code>.scheduleStopActivity()</li>
<li><code>ActivityThread</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.sendMessage()</li>
<li><code>ActivityThread.H</code>.handleMessage()</li>
<li><code>ActivityThread</code>.handleStopActivity()<ul>
<li><code>ActivityThread</code>.performStopActivityInner()</li>
<li><code>ActivityThread</code>.callCallActivityOnSaveInstanceState()</li>
<li><code>Instrumentation</code>.callActivityOnSaveInstanceState()</li>
<li><code>Activity</code>.performSaveInstanceState()</li>
<li><code>Activity</code>.onSaveInstanceState(): 这个方法就是系统销毁时,还原状态数据的方法</li>
</ul>
</li>
<li>回到: <code>ActivityThread</code>.performStopActivityInner() -&gt; 执行了<code>Activity</code>.performStop()</li>
<li><code>Instrumentation</code>.callActivityOnStop()</li>
<li><code>Activity</code>.onStop()</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/11/Window、Activity、DecorView之间的联系以及View的绘制流程/" itemprop="url">
                  Window、Activity、DecorView之间的联系以及View的绘制流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-02-11T17:03:12+08:00" content="2018-02-11">
              2018-02-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/02/11/Window、Activity、DecorView之间的联系以及View的绘制流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/11/Window、Activity、DecorView之间的联系以及View的绘制流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/02/11/Window、Activity、DecorView之间的联系以及View的绘制流程/" class="leancloud_visitors" data-flag-title="Window、Activity、DecorView之间的联系以及View的绘制流程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p><code>Activity</code> 只控制生命周期和处理事件.真正的视图容器是 <code>Window</code>.<strong>Activity像一个管理控制器,管理window来添加与显示View,以及通过其他回调方法,来与 Window 和 View 进行交互</strong></p>
<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p><code>View</code> 的容器,内部持有一个 <code>DecorView</code>,<code>DecorView</code>是View 的根布局.Window 是抽象类,具体实现类是<code>PhoneWindow</code>,<code>PhoneWindow</code>内部有<code>DecorView</code>,通过<code>DecorView</code>来加载<code>Activity</code>设置的布局<code>R.layout.activity_main</code>.<strong><code>Window</code>通过<code>WindowManager</code>将<code>DecorView</code>加载到<code>Window</code>里面,并且将<code>DecorView</code>交给<code>ViewRoot</code>,进行时图绘制和其他交互.</strong></p>
<h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p>Activity 的根节点,我们平时<code>setContentView</code>就是将需要加载的布局添加到 DecorView的<code>Id 叫 content 的子View中了(这个View本质是 FrameLayout).</code></p>
<h2 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h2><p><strong>ViewRoot 对应实现类 ViewRootImpl,他是连接WindowManagerService 和 DecorView 的纽带,所有View的绘制以及事件分发都通过它来执行的</strong></p>
<h3 id="四者关系图"><a href="#四者关系图" class="headerlink" title="四者关系图"></a>四者关系图</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-e773ab2cb83ad214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h2><p>继承自 <code>ViewManager</code>,表示有添加删除 View 的能力</p>
<h2 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h2><p><code>WindowManager</code>实现类,实质是<code>WindowManagerGlobal</code>的代理类</p>
<h2 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h2><p>与 <code>WMS</code> 通讯的类,维护了三个集合:所有<code>DecorView</code>,所有布局参数<code>LayoutParams</code>以及<code>ViewRootImpl</code></p>
<h2 id="WindowSession"><a href="#WindowSession" class="headerlink" title="WindowSession"></a>WindowSession</h2><p>ViewRootImpl与WMS的对话通讯类</p>
<h2 id="DecorView-如何创建的"><a href="#DecorView-如何创建的" class="headerlink" title="DecorView 如何创建的"></a>DecorView 如何创建的</h2><h3 id="setContent"><a href="#setContent" class="headerlink" title="setContent"></a>setContent</h3><p>我们加载布局都是从 Activity 的 <code>setContent</code>开始的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</div><div class="line">    getWindow().setContentView(layoutResID);</div><div class="line">    initWindowDecorActionBar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getWindow()对应于 <code>PhoneWindow</code>,我们看一下 <code>Activity</code> 是如何获得<code>Window</code>对象的,Activity 启动时会调用<code>attach()</code>方法,在这里面初始化了<code>PhoneWindow</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">final void attach(Context context, ActivityThread aThread,</div><div class="line">    Instrumentation instr, IBinder token, int ident,</div><div class="line">    Application application, Intent intent, ActivityInfo info,</div><div class="line">    CharSequence title, Activity parent, String id,</div><div class="line">    NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">    Configuration config, String referrer, IVoiceInteractor voiceInteractor,</div><div class="line">    Window window) &#123;</div><div class="line">        ....</div><div class="line">        mWindow = new PhoneWindow(this, window);//创建一个Window对象</div><div class="line">        mWindow.setWindowControllerCallback(this);</div><div class="line">        mWindow.setCallback(this);//设置回调，向Activity分发点击或状态改变等事件</div><div class="line">        mWindow.setOnWindowDismissedCallback(this);</div><div class="line">        //这就是传说中的UI线程，也就是ActivityThread所在的，</div><div class="line">        mUiThread = Thread.currentThread();</div><div class="line">        ....</div><div class="line">        mWindow.setWindowManager(</div><div class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</div><div class="line">            mToken, mComponent.flattenToString(),</div><div class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);//给Window设置WindowManager对象</div><div class="line">        ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Activity</code> 的 <code>attach</code>方法中,生成了<code>PhoneWindow</code>对象.有了<code>Window</code>对象,.我们就可以将<code>DecorView</code>添加到<code>Window</code>对象.另外初始化了 <code>mUiThread</code>,继续看<code>PhoneWindow</code>的<code>setContentView</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    if (mContentParent == null) &#123;//mContentParent为空，创建一个DecroView</div><div class="line">        installDecor();</div><div class="line">    &#125; else &#123;</div><div class="line">        mContentParent.removeAllViews();//mContentParent不为空，删除其中的View</div><div class="line">    &#125;</div><div class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);//为mContentParent添加子View,即Activity中设置的布局文件</div><div class="line">    final Callback cb = getCallback();</div><div class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">        cb.onContentChanged();//回调通知，内容改变</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>mContentParent</code>就是 contentView 对应的FrameLayout</p>
<p>通过上面流程我们大概可以知道, <code>Activity</code>当<code>attach</code>时就会创建一个 <code>PhoneWindow</code>,而我们的<code>DecorView</code>根视图添加到<code>PhoneWindow</code>的关键时候就是我们的<code>setContentView()</code>方法执行的时候.到这个时候,视图一层一层嵌套上了.</p>
<h3 id="installDecor"><a href="#installDecor" class="headerlink" title="installDecor()"></a>installDecor()</h3><p>在前面的 <code>setContentView</code>方法中,有初始化 <code>DecorView</code>的操作,我们看看怎样创建<code>DecorView</code>并且设置整体布局的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private void installDecor() &#123;</div><div class="line">    if (mDecor == null) &#123;</div><div class="line">         //生成DecorView</div><div class="line">        mDecor = generateDecor();</div><div class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</div><div class="line">        mDecor.setIsRootNamespace(true);</div><div class="line">        if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123;</div><div class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        // 为DecorView设置布局格式，并返回mContentParent</div><div class="line">        mContentParent = generateLayout(mDecor); </div><div class="line">        ...</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="generateDecor"><a href="#generateDecor" class="headerlink" title="generateDecor()"></a>generateDecor()</h3><p>该方法很简单,就是new出了 <code>DecorView</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected DecorView generateDecor() &#123;</div><div class="line">    return new DecorView(getContext(), -1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="generateLayout"><a href="#generateLayout" class="headerlink" title="generateLayout()"></a>generateLayout()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</div><div class="line">    // 从主题文件中获取样式信息</div><div class="line">    TypedArray a = getWindowStyle();</div><div class="line"></div><div class="line">    ...................</div><div class="line">    //设置有无标题栏等一些操作</div><div class="line"></div><div class="line">    ................</div><div class="line"></div><div class="line">    // 根据主题样式，加载窗口布局,一堆 if else 找到布局文件</div><div class="line">    int layoutResource;</div><div class="line">    int features = getLocalFeatures();</div><div class="line">    // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</div><div class="line">    if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123;</div><div class="line">        layoutResource = R.layout.screen_swipe_dismiss;</div><div class="line">    &#125; else if(...)&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //加载主题对应的layoutResource</div><div class="line">    View in = mLayoutInflater.inflate(layoutResource, null);</div><div class="line"></div><div class="line">    //往DecorView中添加主题对应加载的View,到这里DecorView有了布局,而布局里面对应有 `id:content`,所以 contentView 与 DecorView 关联上了</div><div class="line">    decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); </div><div class="line">    mContentRoot = (ViewGroup) in;</div><div class="line">    //获得 `id:content` 对应的 View,这里获取的就是mContentParent</div><div class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    return contentParent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>整体逻辑还是很清晰的</strong></p>
<p><strong>首先从主题获取样式,通过<code>addView</code>加载对应布局到 DecorView,然后根据 <code>id:content</code>获取到 mContentParent.最后我们通过 setContentView 将自己的布局<code>inflate</code> 到 <code>mContentParent</code>中</strong></p>
<blockquote>
<p>注意,这个时候还没有将 DecorView 添加到<code>PhoneWindow</code>中!所以没有显示任何东西</p>
</blockquote>
<h2 id="DecorView-的显示"><a href="#DecorView-的显示" class="headerlink" title="DecorView 的显示"></a>DecorView 的显示</h2><h3 id="为什么-onResume-后才对用户可见呢"><a href="#为什么-onResume-后才对用户可见呢" class="headerlink" title="为什么 onResume()后才对用户可见呢?"></a>为什么 <code>onResume()</code>后才对用户可见呢?</h3><p>这里需要从 <code>ActivityThread</code> 说起,我们启动一个 <code>Activity</code>,会执行到 <code>ActivityThread</code> 的<code>handleLaunchActivity()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line"></div><div class="line">    //就是在这里调用了Activity.attach()，初始化了 PhoneWindow.</div><div class="line">    //接着调用了Activity.onCreate()和Activity.onStart()生命周期，</div><div class="line">    //但是由于只是初始化了mDecor，添加了布局文件，还没有把</div><div class="line">    //mDecor添加到负责UI显示的PhoneWindow中，所以这时候对用户来说，是不可见的</div><div class="line">    Activity a = performLaunchActivity(r, customIntent);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    if (a != null) &#123;</div><div class="line">    //这里面执行了Activity.onResume()</div><div class="line">    handleResumeActivity(r.token, false, r.isForward,</div><div class="line">                        !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</div><div class="line"></div><div class="line">    if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</div><div class="line">        try &#123;</div><div class="line">                r.activity.mCalled = false;</div><div class="line">                //执行Activity.onPause()</div><div class="line">                mInstrumentation.callActivityOnPause(r.activity);</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点看 <code>handleResumeActivity</code>,DecorView 和 <code>ViewRoot</code>将会出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">final void handleResumeActivity(IBinder token, boolean clearHide, </div><div class="line">                                boolean isForward, boolean reallyResume) &#123;</div><div class="line"></div><div class="line">    //这个时候，Activity.onResume()已经调用了，但是现在界面还是不可见的,因为 DecorView 没有添加到 Window 中</div><div class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class="line"></div><div class="line">    if (r != null) &#123;</div><div class="line">        final Activity a = r.activity;</div><div class="line">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</div><div class="line">        //获取 phoneWindows</div><div class="line">            r.window = r.activity.getWindow();</div><div class="line">            //获取 DecorView</div><div class="line">            View decor = r.window.getDecorView();</div><div class="line">            //decor对用户不可见</div><div class="line">            decor.setVisibility(View.INVISIBLE);</div><div class="line">            ViewManager wm = a.getWindowManager();</div><div class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</div><div class="line">            a.mDecor = decor;</div><div class="line"></div><div class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</div><div class="line"></div><div class="line">            if (a.mVisibleFromClient) &#123;</div><div class="line">                a.mWindowAdded = true;</div><div class="line">                //如果可见,那么就添加到 WindowManager中</div><div class="line">                wm.addView(decor, l);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!r.activity.mFinished &amp;&amp; willBeVisible</div><div class="line">                    &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</div><div class="line">                //在这里，执行了重要的操作,使得DecorView可见</div><div class="line">                if (r.activity.mVisibleFromClient) &#123;</div><div class="line">                    r.activity.makeVisible();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 <code>makeVisible</code>,才将界面设置为可见了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void makeVisible() &#123;</div><div class="line">   if (!mWindowAdded) &#123;</div><div class="line">        ViewManager wm = getWindowManager();</div><div class="line">        wm.addView(mDecor, getWindow().getAttributes());//将DecorView添加到WindowManager</div><div class="line">        mWindowAdded = true;</div><div class="line">    &#125;</div><div class="line">    mDecor.setVisibility(View.VISIBLE);//DecorView可见</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>到了这里DecorView才可见,显示在屏幕中</strong>, 其关键作用的是<code>wm.addView(mDecor, getWindow().getAttributes())</code>,因为它的内部创建了 <code>ViewRootImpl</code>,负责绘制各个子View</p>
<p><code>WindowManager</code>继承自<code>ViewManager</code>,他是一个接口.<code>WindowManager具体实现类是 WindowManagerImpl</code>,我们看看他的<code>addView()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public final class WindowManagerImpl implements WindowManager &#123;    </div><div class="line">    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public void addView(View view, ViewGroup.LayoutParams params) &#123;</div><div class="line">        //调用 WindowManagerGlobal 的方法</div><div class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">----------------------WindowManagerGlobal-------</div><div class="line"></div><div class="line">public void addView(View view, ViewGroup.LayoutParams params,</div><div class="line">                    Display display, Window parentWindow) &#123;</div><div class="line"></div><div class="line">    ......</div><div class="line">    synchronized (mLock) &#123;</div><div class="line"></div><div class="line">        ViewRootImpl root;</div><div class="line">        //实例化一个ViewRootImpl对象</div><div class="line">        root = new ViewRootImpl(view.getContext(), display);</div><div class="line">        view.setLayoutParams(wparams);</div><div class="line"></div><div class="line">        mViews.add(view);</div><div class="line">        mRoots.add(root);</div><div class="line">        mParams.add(wparams);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    try &#123;</div><div class="line">        //将DecorView交给ViewRootImpl</div><div class="line">        root.setView(view, wparams, panelParentView);</div><div class="line">    &#125; catch (RuntimeException e) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WindowManagerGlobal 维护了三个集合(添加进来的<code>DecorView</code>,布局参数<code>LayoutParams</code>,和刚才实例化的 <code>ViewRootImpl</code>)</p>
<p><strong>ViewRootImpl的setView()中,调用了 requestLayout() 方法,他经过一系列方法调用(scheduleTraversals() -&gt; doTravelsal() -&gt; performTravelsals()),最终调用了<code>performTraversals()</code>方法,然后绘制流程层层调用,完成绘制,最终界面显示出来了.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</div><div class="line">    ...</div><div class="line">    requestLayout();</div><div class="line">    ...</div><div class="line">    //利用 WindowSession,最终将 ViewRootImpl 与 WindowManagerService 联系起来</div><div class="line">    //将 mWindow 传递给了 WMS,mWindow是内部 `W` 类,他持有 ViewRtootImpl 对象,这样WMS就可以让 ViewRootImpl 做一些事了,主动添加 View 到 Window 中</div><div class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</div><div class="line">        getHostVisibility(), mDisplay.getDisplayId(),</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">-----------requestLayout------</div><div class="line"></div><div class="line">public void requestLayout() &#123;</div><div class="line">        if (!mHandlingLayoutInLayoutRequest) &#123;</div><div class="line">        //检查 UI 操作是否在 UI线程里</div><div class="line">            checkThread();</div><div class="line">            mLayoutRequested = true;</div><div class="line">            //继续调用</div><div class="line">            scheduleTraversals();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">-----------scheduleTraversals-----------</div><div class="line"></div><div class="line">void scheduleTraversals() &#123;</div><div class="line">        ...</div><div class="line">        //发送消息到 Handler 中</div><div class="line">        mChoreographer.postCallback(</div><div class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">在 TraversalRunnable 的 run()方法中</div><div class="line"></div><div class="line">public void run() &#123;</div><div class="line">            doTraversal();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">------------- doTraversal---------</div><div class="line"></div><div class="line">void doTraversal() &#123;</div><div class="line">        ...</div><div class="line">        performTraversals();</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>而对于 Window 添加 <code>DecorView</code>的过程,是通过<code>WindowSession</code>完成的.</strong></p>
<p><strong><code>WindowSession</code>内部会通过 <code>WindowsManagerService的 addToDisplay(mWindow)</code>,让 Session 持有 <code>W</code>类,W类内部持有<code>ViewRootImpl</code>,而<code>ViewRootImpl</code>又持有<code>DecorView</code>,这样WMS可以利用持有的 Session 引用主动添加 DecorView 到Window上</strong></p>
<p><strong>ViewRootImpl 负责管理View树,和通过<code>WindowSession</code>与<code>WMS</code>进行交互,ViewRootImpl也负责UI布局的渲染和一部分事件分发给Activity</strong></p>
<h3 id="为什么-onResume-才能拿到具体的View宽高呢"><a href="#为什么-onResume-才能拿到具体的View宽高呢" class="headerlink" title="为什么 onResume() 才能拿到具体的View宽高呢?"></a>为什么 <code>onResume()</code> 才能拿到具体的View宽高呢?</h3><blockquote>
<p>通过上面分析,我们知道只有在 <code>onResume()</code>后,<code>ViewRootImpl</code>才会开始 <code>performTravelsals</code>进行View层层绘制.绘制完才能拿到具体值.所以也只有在 <code>onResume()</code>后,才能拿到具体View宽高</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Window</code>是虚拟的概念,他是View的容器,具体的对于每个Activity,都有一个 <code>PhoneWindow</code>,里面存储了 <code>DecorView</code>,我们<code>setContentView</code>都是将布局实例化出来添加到<code>DecorView</code>的<code>id:content</code>中了</li>
<li><code>WindowManagerImpl</code>是<code>WindowManager</code>的实现类,他代理了<code>WindowManagerGlobal</code>.</li>
<li><code>WindowManagerGlobal</code>全局只有一个,它保存了App所有的<code>DecorView</code>,所有的<code>contentView</code>以及布局参数<code>LayoutParams</code>.</li>
<li><code>ViewRootImpl</code>都持有<code>WindowSession</code>(WindowSession只有一个),他可以与<code>WindowManagerService</code>通讯.而<code>WMS</code>持有<code>ViewRootImpl::W</code>,<code>W</code>持有了<code>ViewRootImpl</code>也可以向<code>ViewRootImpl</code>通讯</li>
<li>ViewRootImpl 每个Activity都有一个,它负责管理View树,和通过<code>WindowSession</code>与<code>WMS</code>进行交互,ViewRootImpl也负责UI布局的渲染和一部分事件分发给Activity</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/03/View-绘制流程/" itemprop="url">
                  View 绘制流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-02-03T15:48:24+08:00" content="2018-02-03">
              2018-02-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/02/03/View-绘制流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/03/View-绘制流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/02/03/View-绘制流程/" class="leancloud_visitors" data-flag-title="View 绘制流程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>View</code> 的绘制从 <code>ViewRoot</code> 的 <code>performTraversals</code> 方法开始，他经过 <code>measure，layout，draw</code> 三个过程才能将一个 View 绘制出</p>
<ul>
<li><p>对于 draw ,是 <code>performDraw()</code> 以后,他是调用 <code>draw(boolean)</code>,然后调用<code>ThreadedRender.draw(三个参数) -&gt; ThreadedRender.updateRootDisplayList() -&gt; ThreadedRender.updateViewTreeDisplayList() -&gt; View.updateDisplayListIfDirty()</code></p>
</li>
<li><p>在最后的<code>View.updateDisplayListIfDirty()</code>里,才会根据一些标志位(<code>PFLAG_DRAWING_CACHE_VALID , PFLAG_SKIP_DRAW</code>)来判断到底是直接执行我们的 <strong>View.draw(canvas)</strong> 绘制自身还是 <strong>View.dispatchDraw()</strong> 不绘制自身,直接分发事件</p>
</li>
</ul>
<h4 id="针对-performTraversals大致流程如下"><a href="#针对-performTraversals大致流程如下" class="headerlink" title="针对 performTraversals大致流程如下."></a>针对 <code>performTraversals</code>大致流程如下.</h4><p><img src="https://ww3.sinaimg.cn/large/006tKfTcly1fd3x1rxbj3j30iv0c0dgr.jpg" alt=""></p>
<p><code>performTraversals</code> 会依次调用<code>performMeasure, performLayout ,performDraw</code>。其中 <code>performMeasure</code> 会调用 <code>measure</code> 方法， <code>measure</code> 最终会调用 我们自定义的 <code>onMeasure</code>。当然，对于 ViewGroup 来说，onMeasure 就是对所有子元素调用 measure 的过程</p>
<p>对于 layout 过程也是类似的。唯一不同的是 draw 方法，performDraw 传递过程是 draw 方法中通过 dispatchDraw 来实现的，但是本质是一样的。</p>
<h2 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h2><p>ViewRoot 的实现类是 ViewRootImpl ,<strong>他是链接 WindowManager 和 DecorView 的纽带，View 的三大流程均是通过 ViewRoot 来完成的，</strong></p>
<p>在 ActivityThread 中，当 Activity 对象创建完毕后，就会将 DecorView 添加到 Window 中，同时创建 ViewRootImpl,并且将 ViewRootImpl 与 DecorView 建立关联</p>
<p><strong>在 setView 中,最终会调用到 <code>ViewRootImpl</code>的 performTravelsals(),他会依次调用<code>ViewRootImpl的</code> <code>performMeasure(),performLayout(),performDraw()</code>,这番个方法会依次向下遍历,最终完成整个View数的绘制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root = new ViewRootImpl(view.getContext(),display);</div><div class="line">root.setView(view,wparams,panelParentView);</div></pre></td></tr></table></figure>
<h2 id="SpecMode-测量模式"><a href="#SpecMode-测量模式" class="headerlink" title="SpecMode 测量模式"></a>SpecMode 测量模式</h2><h3 id="EXACTLY"><a href="#EXACTLY" class="headerlink" title="EXACTLY"></a>EXACTLY</h3><p>父容器已检测出精确大小。</p>
<blockquote>
<p>对应于 <strong>match_parent</strong></p>
</blockquote>
<h3 id="AT-MOST"><a href="#AT-MOST" class="headerlink" title="AT_MOST"></a>AT_MOST</h3><p>父容器制定了可用大小 SpecSize，View 不能超过这个值。具体值要看 View 的具体实现，比如<code>TextView</code> 根据字数多少定义宽度</p>
<blockquote>
<p>对应于 <strong>wrap_content</strong></p>
</blockquote>
<h3 id="UNSPECIFIED"><a href="#UNSPECIFIED" class="headerlink" title="UNSPECIFIED"></a>UNSPECIFIED</h3><p>父容器不对 View 限制大小。一般用于系统内部，表示一种测量状态。</p>
<h2 id="View-工作流程"><a href="#View-工作流程" class="headerlink" title="View 工作流程"></a>View 工作流程</h2><h3 id="measure-过程"><a href="#measure-过程" class="headerlink" title="measure 过程"></a>measure 过程</h3><p>measure 的作用是测量 View 的宽高</p>
<p>如果是 子View，那么 measure 方法就完成了测量过程</p>
<p>如果是 ViewGroup，除了测量自身，还需要<strong>遍历去调用所有子元素的 measure 方法</strong></p>
<h4 id="onMeasure-方法"><a href="#onMeasure-方法" class="headerlink" title="onMeasure 方法"></a>onMeasure 方法</h4><h5 id="View-的-onMeasure"><a href="#View-的-onMeasure" class="headerlink" title="View 的 onMeasure"></a>View 的 onMeasure</h5><p>measure 方法会调用 onMeasure 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>setMeasureDimension 方法就会设置 View 的宽高测量值</strong></p>
<p><code>getDesaultSize()</code>返回的大小就是 <code>measureSpec 中的 specSize</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MeasureSpec.getSize(measureSpec)</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意，继承 View 的自定义控件需要重写 onMeasure 方法<strong>并且设置 wrap_content时候的自身大小</strong> 。</p>
</blockquote>
<p>因为从测量模式中得知，子View<code>wrap_content</code>模式下，他的 specMode 是 <code>AT_MOST</code>,这种情况下宽高都是 parentSize</p>
<blockquote>
<p>默认只有 <code>dp</code> 精确模式下，计算出的宽高才是 子View 的真实宽高</p>
</blockquote>
<h5 id="ViewGroup-的-onMeasure"><a href="#ViewGroup-的-onMeasure" class="headerlink" title="ViewGroup 的 onMeasure"></a>ViewGroup 的 onMeasure</h5><p>对于 ViewGroup 来说，除了完成自身的 measure 过程，还会遍历调用 子View 的 measure 方法，所以它提供了一个方法，让我们遍历调用子View</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        final int size = mChildrenCount;</div><div class="line">        final View[] children = mChildren;</div><div class="line">        for (int i = 0; i &lt; size; ++i) &#123;</div><div class="line">            final View child = children[i];</div><div class="line">            if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">            //遍历子View，调用 measureChild</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">--------------measureChild 方法------------</div><div class="line">protected void measureChild(View child, int parentWidthMeasureSpec,</div><div class="line">            int parentHeightMeasureSpec) &#123;</div><div class="line">        final LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom, lp.height);</div><div class="line">        //计算 childMeasureSpec ，然后调用 child 自身的 measure 方法</div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="layout-过程"><a href="#layout-过程" class="headerlink" title="layout 过程"></a>layout 过程</h3><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><p>layout 的作用是 <code>ViewGroup</code> 确定 子View 的位置,当 ViewGroup 的位置被确定后，他在 <code>onLayout</code> 中会遍历所有子View并调用<code>layout</code>方法,子View 的 <code>layout</code>方法又会调用 <code>onLayout</code> 方法</p>
<p><strong>自定义 ViewGroup 才需要重写 onLayout 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        int oldL = mLeft;</div><div class="line">        int oldT = mTop;</div><div class="line">        int oldB = mBottom;</div><div class="line">        int oldR = mRight;</div><div class="line">        //通过 setFrame 判断是否需要 layout</div><div class="line">        boolean changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">        //调用 onLayout 方法</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line"></div><div class="line">            if (shouldDrawRoundScrollbar()) &#123;</div><div class="line">                if(mRoundScrollbarRenderer == null) &#123;</div><div class="line">                    mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                mRoundScrollbarRenderer = null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                int numListeners = listenersCopy.size();</div><div class="line">                for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line"></div><div class="line">        if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) &#123;</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;</div><div class="line">            notifyEnterOrExitForAutoFillIfNeeded(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>setFrame 用于判断布局大小是否变过，从而判断是否需要重绘.<strong>如果布局发生过变化,会调用 invalidate() 进而调用 draw()</strong></p>
<p>onLayout 在 View 和 ViewGroup 中都没有实现，需要我们在自定义 ViewGroup 时自己实现对所有 子View 的 位置确定</p>
<h2 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h2><p>前面分析我们知道,<code>performDraw()</code>经过几个步骤和几个类,才最终调用到<code>draw(canvas)</code></p>
<p>draw 作用是将 View 绘制到屏幕上，draw 流程 遵守以下几个步骤</p>
<ul>
<li>绘制背景 <code>backgourd.draw(canvas)</code></li>
<li>绘制自身 <code>onDraw</code></li>
<li>绘制 children <code>dispatchDraw</code> ,这里与 <code>measure</code> 和 <code>layout</code> 不同，不需要手动遍历调用子View 相应方法</li>
<li>绘制装饰，比如滚动条 <code>onDrawScrollBars</code></li>
</ul>
<p>该方法比较简单，就不再看源码了。View 的绘制过程传递是通过 <code>dispatchDraw</code> 来实现的，他会遍历调用所有 子View 的 <code>draw</code> 方法</p>
<p><strong>以上就是 View 绘制流程的三个步骤</strong></p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><h4 id="getHeight-与-getMeasureHeight-有什么区别"><a href="#getHeight-与-getMeasureHeight-有什么区别" class="headerlink" title="getHeight 与 getMeasureHeight 有什么区别"></a>getHeight 与 getMeasureHeight 有什么区别</h4><ul>
<li><code>getMeasureHeight</code> 在 <code>measure</code> 结束就可获取了，而 <code>getHeight</code> 需要在 <code>layout</code> 结束才能获取</li>
<li><code>getMeasureHeight</code> 是通过 <code>setMeasuredDimission</code> 传入的值获取的。而 <code>getHeight</code> 是通过 <code>下坐标 减去 上坐标</code> 获取的</li>
<li>默认情况下两者相同，但是如果 <code>layout</code>的时候传入不恰当的值，那么就会导致获取到的值不相同</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;   </div><div class="line">    View childView = getChildAt(0);  </div><div class="line">    childView.layout(l, t, r+200, b+200);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样认为去修改错误的值，会导致最终的宽高总是多 200px</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>View的绘制流程,是从<code>ViewRootImpl</code>的<code>performTravelsals()</code>开始的,他会依次向下遍历,调用对应方法完成绘制.</p>
<p>performTraversals()会调用<code>performMeasure,performLayout(),performDraw()</code>,在这些方法的内部会对应调用<code>measure(),layout(),draw()</code>,<strong>draw()稍微复杂点,会有 SKIP_DRAW等一些标志位的判断</strong>,最终会调用到我们重写的方法<code>onMeasure(),onLayout(),onDraw()</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/Binder-机制/" itemprop="url">
                  Binder 机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-03T23:08:10+08:00" content="2017-05-03">
              2017-05-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/03/Binder-机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/03/Binder-机制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/05/03/Binder-机制/" class="leancloud_visitors" data-flag-title="Binder 机制">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Binder-存在的意义-为什么要使用Binder"><a href="#Binder-存在的意义-为什么要使用Binder" class="headerlink" title="Binder 存在的意义?为什么要使用Binder"></a>Binder 存在的意义?为什么要使用Binder</h3><h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。</p>
</blockquote>
<p>操作系统的不同进程之间，数据不共享；对于每个进程来说，因此一个进程需要与另外一个进程通信，需要某种系统机制才能完成。</p>
<h4 id="跨进程方式"><a href="#跨进程方式" class="headerlink" title="跨进程方式"></a>跨进程方式</h4><ul>
<li><p>Linux 传统跨进程(未严格验证通信双方身份)</p>
<ul>
<li>Socket</li>
<li>管道</li>
</ul>
</li>
<li><p>Android : <strong>Binder</strong></p>
<ul>
<li>动态可加载模块 LKM: 运行时被动态加载到内核,作为内核的一部分.成为内核与用户空间的桥梁,完成通信.Android 中称为 <code>Binder 驱动</code></li>
</ul>
</li>
</ul>
<h3 id="Binder-使用"><a href="#Binder-使用" class="headerlink" title="Binder 使用"></a>Binder 使用</h3><p>想要使用跨进程通信 Binder,最常见的就是Service中,我们首先需要创建一个 <code>aidl</code>文件,里面定义好跨进程通信的接口.</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface IRemote &#123;</div><div class="line">    int getAIDLResult(int i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们 <code>Rebuild</code> 一下,编译器会自动生成对应的 Java 文件,</p>
<h3 id="Demo-演示"><a href="#Demo-演示" class="headerlink" title="Demo 演示"></a>Demo 演示</h3><h4 id="Server-端"><a href="#Server-端" class="headerlink" title="Server 端"></a>Server 端</h4><p>我们创建一个远程 Service 对象,并且覆盖onBind() 方法并返回 IRemoteService.Stub 实例 mBinder<br>注意到 Stub 是一个抽象类,我们得实现 <code>aidl</code>文件中定义的方法.</p>
<p>Service</p>
<ul>
<li>本地服务:依附于主进程,非独立进程,无进程隔离</li>
<li>远程服务:<strong>声明android:process=”:remote”</strong>,成为独立进程,有进程隔离,需要使用AIDL进行IPC</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class RemoteService extends Service &#123;</div><div class="line"></div><div class="line">    private static final String TAG = RemoteService.class.getSimpleName();</div><div class="line">    </div><div class="line">    private  IRemote.Stub mBinder = new IRemote.Stub()&#123;</div><div class="line">        @Override</div><div class="line">        public int getAIDLResult(int result) throws RemoteException &#123;</div><div class="line">            Log.e(&quot;AIDLDemo&quot;,&quot;Service getRequest&quot;);</div><div class="line">            Log.e(&quot;AIDLDemo ; &quot;,&quot;Service pid &quot;+android.os.Process.myPid() );</div><div class="line">            return i+1;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        return mBinder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Client-端"><a href="#Client-端" class="headerlink" title="Client 端"></a>Client 端</h4><p>我们在客户端服务连接 <code>ServiceConnection</code> 的 <code>onServiceConnected()</code> 获取到了 IBinder 实例,通过 Binder 的 <code>asInterface</code> 获取到了远程服务的代理对象 <code>remoteService</code>,最后我们通过 <code>remoteService.getResult()</code> 就可以像本地方法一样调用远程服务的方法了,实现了跨进程通信.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    private ServiceConnection mConnection = new ServiceConnection() &#123;</div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">        //通过 asInterface ,获取 Binder 代理对象,调用远程方法跨进程通信</div><div class="line">            IRemote remoteService = IRemote.Stub.asInterface(service);</div><div class="line">            try &#123;</div><div class="line">                remoteService.getResult();</div><div class="line">            &#125; catch (RemoteException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        ...</div><div class="line">        //启动Service</div><div class="line">        Intent intent = new Intent(this,MyService.class);</div><div class="line">        bindService(intent,mServiceConnection,BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Q: IBinder是什么,IInterface是什么,IBinder为什么能转成IInterface</div></pre></td></tr></table></figure></p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>我们来分析一下这个文件.需要了解的地方已经写在注释中了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">public interface IRemote extends android.os.IInterface &#123;</div><div class="line">    </div><div class="line">    public static abstract class Stub extends android.os.Binder implements com.mashell.taskb.IRemote &#123;</div><div class="line">        private static final java.lang.String DESCRIPTOR = &quot;com.mashell.taskb.IRemote&quot;;</div><div class="line"></div><div class="line">        public Stub() &#123;</div><div class="line">            this.attachInterface(this, DESCRIPTOR);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //客户端通过 Stub.asInterface() 得到 Binder 代理对象,远程调用 Server 的方法,实现跨进程通信.</div><div class="line">        public static com.mashell.taskb.IRemote asInterface(android.os.IBinder obj) &#123;</div><div class="line">            if ((obj == null)) &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            //查找本地 Binder 对象</div><div class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">            //找到了而且是同一个进程,直接向上转型成 Binder 本地对象.</div><div class="line">            if (((iin != null) &amp;&amp; (iin instanceof com.mashell.taskb.IRemote))) &#123;</div><div class="line">                return ((com.mashell.taskb.IRemote) iin);</div><div class="line">            &#125;</div><div class="line">            //不是同一个进程,返回 Binder 代理对象.</div><div class="line">            return new com.mashell.taskb.IRemote.Stub.Proxy(obj);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public android.os.IBinder asBinder() &#123;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //Service端处理请求的方法</div><div class="line">        @Override</div><div class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</div><div class="line">            switch (code) &#123;</div><div class="line">                case INTERFACE_TRANSACTION: &#123;</div><div class="line">                    reply.writeString(DESCRIPTOR);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                case TRANSACTION_getResult: &#123;</div><div class="line">                    data.enforceInterface(DESCRIPTOR);</div><div class="line">                    int _arg0;</div><div class="line">                    _arg0 = data.readInt();</div><div class="line">                    //调用我们定义的方法,是抽象方法,需要在服务端实例中重写实现这个方法</div><div class="line">                    this.getResult(_arg0);</div><div class="line">                    reply.writeNoException();</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return super.onTransact(code, data, reply, flags);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //具体的代理类, 远程 Binder</div><div class="line">        private static class Proxy implements com.mashell.taskb.IRemote &#123;</div><div class="line">            private android.os.IBinder mRemote;</div><div class="line"></div><div class="line">            Proxy(android.os.IBinder remote) &#123;</div><div class="line">                mRemote = remote;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public android.os.IBinder asBinder() &#123;</div><div class="line">                return mRemote;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public java.lang.String getInterfaceDescriptor() &#123;</div><div class="line">                return DESCRIPTOR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void getResult(int result) throws android.os.RemoteException &#123;</div><div class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">                try &#123;</div><div class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    _data.writeInt(result);</div><div class="line">                   //对于跨进程调用方法,调用 transact() 这个 native 方法,要知道最终调用 talkWithDriver 方法</div><div class="line">                   //然后该函数通过 ioctl 系统调用, Client 进程陷入内核态,Client 调用我们定义的 getResult 方法线程挂起等待返回.</div><div class="line">                   //Binder 驱动操作后唤醒 Server进程,调用 Binder 本地对象的 onTransact 函数.</div><div class="line">                   //该函数通过参数判断调用到具体对应的函数.最终Binder 驱动唤醒 Client 并将结果返回.</div><div class="line">                   mRemote.transact(Stub.TRANSACTION_getResult, _data, _reply, 0);</div><div class="line">                    _reply.readException();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    _reply.recycle();</div><div class="line">                    _data.recycle();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        static final int TRANSACTION_getResult = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void getResult(int result) throws android.os.RemoteException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="asInterface"><a href="#asInterface" class="headerlink" title="asInterface()"></a>asInterface()</h4><h5 id="asInterface-拿到-IBinder-对象-让我们来分析一下这个方法"><a href="#asInterface-拿到-IBinder-对象-让我们来分析一下这个方法" class="headerlink" title="asInterface() 拿到 IBinder 对象,让我们来分析一下这个方法"></a>asInterface() 拿到 IBinder 对象,让我们来分析一下这个方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static com.mashell.taskb.IRemote asInterface(android.os.IBinder obj) &#123;</div><div class="line">            if ((obj == null)) &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">            if (((iin != null) &amp;&amp; (iin instanceof com.mashell.taskb.IRemote))) &#123;</div><div class="line">                return ((com.mashell.taskb.IRemote) iin);</div><div class="line">            &#125;</div><div class="line">            return new com.mashell.taskb.IRemote.Stub.Proxy(obj);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>Binder 会根据情况查找返回 Binder 对象,如果是同一进程就直接返回 <strong>Binder</strong> 本地对象.如果是跨进程那么就返回 <strong>BinderProxy</strong></p>
<h5 id="queryLocalInterface"><a href="#queryLocalInterface" class="headerlink" title="queryLocalInterface()"></a>queryLocalInterface()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">在 Binder 类中,查找本地 Interface 返回</div><div class="line">public IInterface queryLocalInterface(String descriptor) &#123;</div><div class="line">        if (mDescriptor.equals(descriptor)) &#123;</div><div class="line">            return mOwner;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">在 BinderProxy 中,直接返回 null</div><div class="line">public IInterface queryLocalInterface(String descriptor) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对于 asInterface,通过上面的分析,</p>
<ul>
<li>如果是同一进程直接向下转型</li>
<li>如果是跨进程的<strong>BinderProxy</strong>,返回一个 Proxy(IBinder mRemote);</li>
</ul>
<p>对于我们远程服务端方法的调用,</p>
<ul>
<li>Binder 本地对象,不需要跨进程,直接调用抽象方法</li>
<li>对于 Binder 代理对象,<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int getAIDLResult(int i) throws android.os.RemoteException &#123;</div><div class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">    int _result;</div><div class="line">    try &#123;</div><div class="line">        _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">        _data.writeInt(i);</div><div class="line">        </div><div class="line">        mRemote.transact(Stub.TRANSACTION_getAIDLResult, _data, _reply, 0);</div><div class="line">        _reply.readException();</div><div class="line">        _result = _reply.readInt();</div><div class="line">    &#125; finally &#123;</div><div class="line">        _reply.recycle();</div><div class="line">        _data.recycle();</div><div class="line">    &#125;</div><div class="line">    return _result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>重点看 <strong>transact()</strong>,既然是 BinderProxy,我们进入具体类中查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public native boolean transactNative(int code, Parcel data, Parcel reply,</div><div class="line">            int flags) throws RemoteException;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件，里面进行了一系列的函数调用，调用链实在太长这里就不给出了；要知道的是它最终调用到了talkWithDriver函数；看这个函数的名字就知道，通信过程要交给驱动完成了；这个函数最后通过ioctl系统调用，Client进程陷入内核态，Client调用add方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的onTransact函数（实际上由Server端线程池完成）。</p>
</blockquote>
<h5 id="onTransact"><a href="#onTransact" class="headerlink" title="onTransact()"></a>onTransact()</h5><p>在 <strong>BinderProxy</strong> 的transact()中,我们传入了编号,默认命名是 <strong>TRANSACTION</strong>+方法名,在 <strong>onTransact()</strong> 方法中,通过编号调用具体函数,唤醒Client 返回结果.</p>
<h3 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h3><p><img src="http://img.blog.csdn.net/20170107102830444" alt=""></p>
<h3 id="Binder-模型大致通信过程"><a href="#Binder-模型大致通信过程" class="headerlink" title="Binder 模型大致通信过程"></a>Binder 模型大致通信过程</h3><ul>
<li><p>在Android开机启动过程中，Android会初始化系统的各种Service，</p>
</li>
<li><p>Service向ServiceManager注册（即让ServiceManager管理）。(跨进程)</p>
</li>
<li><p>客户端想要得到具体的Service直接向ServiceManager要即可。客户端首先向ServiceManager查询得到具体的Service引用，然后通过这个引用向具体的服务端发送请求，服务端执行完成后就返回。(跨进程)</p>
</li>
</ul>
<p>PS:Client向ServiceManager通信的过程也要跨进程通信.<br>从Client和Server的角度来看，ServiceManager永远都是一个Server，任何访问ServiceManager的都是Client。</p>
<h3 id="Binder-驱动"><a href="#Binder-驱动" class="headerlink" title="Binder 驱动"></a>Binder 驱动</h3><p>Binder 驱动是一段运行在内核空间的代码,他是 Binder 机制的核心,负责 Binder 节点的建立和进程间信息的传递.通过 <code>&quot;/dev/binder&quot;</code>的文件在内核空间和用户空间来回搬动数据. <code>Linux inctl</code> 函数实现了从用户空间转移到内核空间的功能.</p>
<h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><p>ServiceManager提供了注册,检索服务的功能.所有的服务由 ServiceManager 统一管理.<br>他做了三件事</p>
<ol>
<li>打开设备文件 <code>/dev/binder</code>,把文件内容映射到内核空间,借助这块区域,可以实现进程间通信.</li>
<li>将当前进程注册到 <code>Binder 驱动</code>,系统会将跨进程的服务注册到他的服务列表中.</li>
<li>ServiceManager也会进入一个无限循环,等待客户端 IPC 请求状态.</li>
</ol>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p><code>ActivityManagerService,WindowManagerService</code>等系统服务,都会调用 <code>ServiceManager.addService()</code>方法添加到 <code>ServiceManager</code>的服务列表中</p>
<ol>
<li>Server将自己作为对象,附上一个句柄为0的值(用于访问 ServiceManager),并将这些内容封装成数据报发送给 <code>Binder驱动</code></li>
<li><code>Binder驱动</code>先检查是否有Server对应的Binder实体,没有就创建 <code>Binder实体</code>并且赋予一个大于0的句柄,然后把句柄和服务名称等信息发送给ServiceManager</li>
<li>ServiceManager检查服务列表中是否有这个服务,不存在就将服务和它的句柄放入到服务列表中.</li>
</ol>
<h3 id="客户端调用服务"><a href="#客户端调用服务" class="headerlink" title="客户端调用服务"></a>客户端调用服务</h3><ol>
<li>客户端想调用某个服务,把<code>服务名+句柄0的值</code>封装成数据报发送给 <code>Binder 驱动</code></li>
<li><code>Binder驱动接收到句柄0</code>,把数据包发给 <code>ServiceManager</code></li>
<li><code>ServiceManager</code>接收到数据包后,找到对应服务,将服务的结果发给 <code>Binder驱动</code>,再发给客户端</li>
<li>客户端收到句柄后,利用句柄在本地创建 <code>远程Server的代理对象</code></li>
<li>客户端调用这个服务,会加上<code>参数,标志服</code>等数据放入 <code>Client的共享内存</code>,Binder驱动根据数据找到 <code>Server 的共享内存</code>,<strong>把数据拷贝到内核空间,并且映射到远程服务进程中,执行 onTrasact() 函数</strong></li>
<li>远程服务执行完后将结果写入自己的共享内存,<strong>Binder驱动再将数据结果拷贝到内核空间,映射到用户端进程中,唤醒客户端线程</strong></li>
</ol>
<h3 id="Binder-如何实现拷贝一次"><a href="#Binder-如何实现拷贝一次" class="headerlink" title="Binder 如何实现拷贝一次"></a>Binder 如何实现拷贝一次</h3><p>Linux 内核只有 用户空间拷贝到内核空间 <code>copy_from_user</code> 和内核空间到用户空间 <code>copy_to_user</code> ,为了实现 用户到用户 的拷贝. <code>mmap()</code>分配的内存除了映射到接收方进程(接收方可以使 Server 也可以是 Client),还映射到内核空间,所以 <code>copy_from_user</code>时,将数据拷贝到内核空间也相当于拷贝到了接收方的用户空间,这就是拷贝一次的原因.</p>
<h3 id="IBinder-IInterface-Binder-BinderProxy-Stub-代表什么"><a href="#IBinder-IInterface-Binder-BinderProxy-Stub-代表什么" class="headerlink" title="IBinder IInterface Binder BinderProxy Stub 代表什么"></a>IBinder IInterface Binder BinderProxy Stub 代表什么</h3><ul>
<li><strong>IBinder</strong> 表示跨进程传输的能力</li>
<li><strong>IInterface</strong> 代表远程服务具体有那种能力 (IRemote 继承自 IInterface)</li>
<li><strong>Binder</strong> Binder 本地对象. </li>
<li><strong>BinderProxy</strong> 远程 Binder 的代理对象,与Binder类在同一个类文件中 (文章错误)</li>
<li><strong>Stub</strong> Binder 本地对象,需要我们具体去实现</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/17/JVM学习笔记-五-JVM方法调用内部机制/" itemprop="url">
                  JVM学习笔记(五):JVM方法调用内部机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-17T17:46:56+08:00" content="2017-04-17">
              2017-04-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/17/JVM学习笔记-五-JVM方法调用内部机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/17/JVM学习笔记-五-JVM方法调用内部机制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/04/17/JVM学习笔记-五-JVM方法调用内部机制/" class="leancloud_visitors" data-flag-title="JVM学习笔记(五):JVM方法调用内部机制">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JVM方法调用的内部机制</p>
<h3 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h3><p>为了调用方法和返回方法,JVM维护了一个栈结构,里面存放的实体称为栈帧,每个栈帧包括 <strong>局部变量表</strong> <strong>操作数栈</strong> <strong>动态链接</strong> <strong>方法返回地址</strong> 和额外的信息.在编译期,栈帧需要多大的局部变量表已经确定了</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>存放方法参数和方法内创建的局部变量,局部变量表的容量以 Slot 为最小单位,一个 Slot 可以存放一个 32位以内的数据类型.<strong>long double 需要两个</strong></p>
<p>如果方法时非 <code>static</code> 的,那么局部变量表中第0位索引 Slot 默认用于传递方法所属对象实例的引用   <strong>(this)</strong></p>
<p>为了节省栈帧空间,Slot是可以重用的,一个局部变量定义了没有赋初始值是不能用的</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>JVM解析执行字节码是基于栈结构,调用其他方法是通过操作数栈来进行参数传递的</p>
<h5 id="方法大致调用过程"><a href="#方法大致调用过程" class="headerlink" title="方法大致调用过程"></a>方法大致调用过程</h5><ul>
<li>每一次调用指令前,JVM把方法被调用的<strong>对象引用</strong>引入操作数栈,JVM还会把<strong>方法的参数</strong>依次放入<strong>操作数栈</strong></li>
<li>调用方法的时候,JVM将参数和对象引用依次从操作数栈弹出,并建立一个新的栈帧存放刚才弹出的变量放入 Slot 1,2,3..</li>
<li>JVM把新栈帧push入<strong>虚拟机方法栈</strong>,并把PC指向函数第一条待执行的指令</li>
</ul>
<blockquote>
<p>JVM通过编译器的静态绑定或者运行时期的动态绑定获取被调用方法的地址</p>
</blockquote>
<h3 id="方法调用字节码指令"><a href="#方法调用字节码指令" class="headerlink" title="方法调用字节码指令"></a>方法调用字节码指令</h3><ul>
<li>invokestatic 调用静态方法</li>
<li>invokespecial 调用实例构造器<init>,私有方法和父类方法</init></li>
<li>invokeVirtual 调用所有的<strong>虚方法</strong>(静态方法,私有方法,实例构造器,父类方法,final 方法 都不是 虚方法)</li>
<li>invokeinterface 调用接口方法,在运行时期确定一个实现此接口的对象</li>
</ul>
<p>invokestatic 和 invokespecial 在类加载阶段就把符号解析为该方法的引用,静态</p>
<p>invokevirtual和invokeinterface 是在运行时确定具体的方法地址</p>
<h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>当JVM 遇到 invokevirtual或者invokeinterface时,需要运行时根据方法符号找到方法地址,具体过程如下</p>
<ul>
<li>方法调用前,将对象的引用压入操作数栈</li>
<li>方法调用时,找到操作数栈顶的第一个元素所指向的对象实际类型,记为C</li>
<li>在 C类中找到常量池中描述符和方法名都相符的方法,并校验访问权限,找到方法并通过校验,就返回这个方法的引用</li>
<li>没找到继续按照继承关系向上找并且校验权限</li>
<li>还是没找到 抛出<code>AbstractMethodError</code>异常</li>
</ul>
<p>为了提高动态分配时候方法查找的效率,JVM为每个类维护一个虚函数表</p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>目的:为了快速找到方法索引地址</p>
<p>JVM在链接类的过程中,给每个类分配相应方法表内存空间,每个类对应一个方法表,都存在于 <strong>方法区</strong> 中,Java 每个对象的<strong>对象头</strong>有一个类型指针,可以找到对应的类,类数据中对应一个方法表,类级别的方法表</p>
<p><strong>方法表</strong>包含了类所有方法的入口地址,<strong>父类继承</strong>的方法放在前面,然后是**接口</p>
<p><img src="http://img.blog.csdn.net/20170818151037199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGVsbEg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h4 id="invokevirtual-与-invokeInterface-区别"><a href="#invokevirtual-与-invokeInterface-区别" class="headerlink" title="invokevirtual 与 invokeInterface 区别"></a>invokevirtual 与 invokeInterface 区别</h4><p><strong>invokevirtual</strong>虚方法是按照父类到子类的顺序排序的,因此使用 invokevirtual 调用虚函数,JVM可以再编译器就确定虚函数在方法表上的 offset ,从而快速定位方法地址</p>
<p><strong>invokeInterface</strong> 接口可以由不同的类实现,所以接口方法在不同类的中 方法表 offset 都不一样,因此每次调用接口方法,都要搜寻一遍虚函数表,效率低于 <strong>invokevirtual</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/15/JVM学习笔记-四-类加载机制/" itemprop="url">
                  JVM学习笔记(四):类加载机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-15T17:45:57+08:00" content="2017-04-15">
              2017-04-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/15/JVM学习笔记-四-类加载机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/15/JVM学习笔记-四-类加载机制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/04/15/JVM学习笔记-四-类加载机制/" class="leancloud_visitors" data-flag-title="JVM学习笔记(四):类加载机制">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><ul>
<li>new getstatic putstatis invokestatic 四个字节码指令</li>
<li>反射</li>
<li>发现父类还没有进行初始,加载父类</li>
<li>main方法所在的类</li>
<li>当用 jdk 1.7动态语言支持ref_getstatic  ref_putStatic ref_invokeStatic 三个句柄</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul>
<li><p><strong>加载 </strong></p>
<ul>
<li>通过一个类的全限定名获取类的二进制字节流</li>
<li>将字节流代表的静态存储结构转为方法区的运行时数据结构</li>
<li>内存中生成一个<code>Class</code>对象,作为方法区这个类的各种数据访问入口</li>
</ul>
</li>
<li><p><strong>验证</strong> :确保字节流包含的信息符合要求</p>
<ul>
<li><strong>文件格式验证</strong>:是否符合Class文件规范</li>
<li><strong>元数据验证</strong>:对<strong>类的元数据</strong>语义分析,符合java语言规范</li>
<li><strong>字节码验证</strong>:对<strong>类的方法体</strong>进行校验分析</li>
<li><strong>符号引用雅正</strong></li>
</ul>
</li>
<li><p><strong>准备</strong>:为类变量分配内存和设置初始值 ,所需内存都在方法去分配</p>
<ul>
<li>类变量指的 <code>static</code> 修饰的变量</li>
<li>初始值指的 零值,不是人为代码的赋值</li>
</ul>
</li>
<li><p><strong>解析</strong> : 将常量池的符号引用替换为直接引用</p>
</li>
<li><p><strong>初始化</strong>  :赋值人为设置的值</p>
</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>除了顶端的加载器,其他加载器都应该有父类的加载器</p>
<ul>
<li>启动类加载器 (BootStrap) C++实现 虚拟机自身一部分</li>
<li>其他类加载器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public void loadClass()&#123;</div><div class="line">	Class c findLoadedClass(name);</div><div class="line">	//类没有被加载过</div><div class="line">	if(c == null)&#123;</div><div class="line">		//尝试加载父类的加载器</div><div class="line">		if(parent != null)&#123;</div><div class="line">			//一层一层向顶部递归调用</div><div class="line">			c = parent.loadClass();</div><div class="line">		&#125;else &#123;</div><div class="line">			//找到最顶端还是没找到,调用 bootstrap</div><div class="line">			c  = findBootstrapClass();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	if(c == null)&#123;</div><div class="line">		//父类无法加载</div><div class="line">		c = findClass();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>过程:调用父类的加载器,父类无法完成再调用自己的加载器</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/JVM学习笔记-三-Java内存模型/" itemprop="url">
                  JVM学习笔记(三):Java内存模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-10T16:10:39+08:00" content="2017-04-10">
              2017-04-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/10/JVM学习笔记-三-Java内存模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/10/JVM学习笔记-三-Java内存模型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/04/10/JVM学习笔记-三-Java内存模型/" class="leancloud_visitors" data-flag-title="JVM学习笔记(三):Java内存模型">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h3><p>目标:定义程序各个变量的访问规则</p>
<ul>
<li><strong>主内存</strong>(共享-&gt;java堆): 所有变量都存储在这</li>
<li><strong>工作内存</strong>(私有-虚拟机栈): 变量在工作内存中只是拷贝的副本</li>
</ul>
<h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>java内存模型定义了以下八种操作,都是原子性的</p>
<ul>
<li>lock(锁定)</li>
<li>unlock(解锁)</li>
<li>read(读取)</li>
<li>load(载入)</li>
<li>use(使用)</li>
<li>assign(赋值)</li>
<li>store(存储)</li>
<li>write(写入)</li>
</ul>
<p>使用八种操作要符合以下规则</p>
<ul>
<li>一个新变量只能在<strong>主内存</strong>中诞生,对一个变量 <code>use,store</code>前,必须 <code>assign和load</code></li>
<li>对一个变量 <code>lock</code> 了,那么会清空 <strong>工作内存</strong> 中变量的值,然后需要重新<code>load或assign</code></li>
<li>对一个变量 <code>unlock</code> 之前,必须把变量同步回<strong>主内存</strong>中,<code>store,write</code></li>
</ul>
<h3 id="volatile-操作"><a href="#volatile-操作" class="headerlink" title="volatile 操作"></a>volatile 操作</h3><ul>
<li>保证了可见性原理<ul>
<li>产生一个<strong>内存屏障</strong>:他使用一个<code>lock</code>操作,这样会清空工作内存的值,然后从新执行<code>load assign</code>,获取主内存的最新数据</li>
<li><code>lock</code>后会<code>unlock</code>,会执行 <code>store,write</code>,将数据写回主内存,通过这两点保证了可见性</li>
</ul>
</li>
<li>保证了有序性:<ul>
<li>因为<strong>内存屏障</strong>,lock指令会把修改同步到主内存中,这样形成了<code>指令重排序无法越过内存屏障</code>也就是volatile</li>
</ul>
</li>
</ul>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul>
<li>八个基本操作是原子性的,基本数据类型的访问读写是具有原子性的</li>
<li>更大范围需要保证原子性,可以用<strong>synchronized</strong></li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>一个线程修改了共享变量的值,其他线程能立即获取到这个修改</p>
<ul>
<li><strong>synchronized</strong> 通过 <code>unlock</code> 之前,必须将变量同步回主内存</li>
<li><strong>final</strong> 通过 不传递 <code>this</code></li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><ul>
<li>volatile 通过<code>禁止指令重排序</code>保证有序性</li>
<li>synchronized 通过 <code>一个变量同一时刻只能有一个线程 lock</code></li>
</ul>
<h4 id="先行先发生-hapends-before"><a href="#先行先发生-hapends-before" class="headerlink" title="先行先发生 hapends-before"></a>先行先发生 hapends-before</h4><p>如果两个操作间的关系不在下面规则内,那么就没有顺序性保障</p>
<ul>
<li><strong>程序次序规则</strong>:单个线程内程序流顺序</li>
<li><strong>官程锁定规则</strong>:对于同一个锁,<code>unlock</code>发生在<code>lock</code>之前</li>
<li><strong>valatile 变量规则</strong></li>
<li><strong>线程启动规则</strong>:start()先行于线程内任何操作</li>
<li><strong>线程终止规则</strong>:所有操作先行于 线程终止</li>
<li><strong>线程中断规则</strong>:<code>interrupt()</code>先行发生于被中断的代码</li>
<li><strong>对象终结规则</strong>:对象的初始化先行于 <code>finalize()</code></li>
<li><strong>传递性</strong></li>
</ul>
<h3 id="JAVA-与-线程"><a href="#JAVA-与-线程" class="headerlink" title="JAVA 与 线程"></a>JAVA 与 线程</h3><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><ul>
<li>使用内核线程实现</li>
<li>使用用户线程实现</li>
<li>使用用户线程+轻量级进程(线程)实现<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4></li>
<li>协同式调度:执行时间由线程本身控制</li>
<li>抢占式调度,由系统分配执行时间</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://img2.ph.126.net/6h6Q_uZfZJyGMEqRVeJEmQ==/6631626317608930421.png"
               alt="mashell" />
          <p class="site-author-name" itemprop="name">mashell</p>
          <p class="site-description motion-element" itemprop="description">还有什么比不浪费时间更有意义的事呢？</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mashell</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"mashell"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("F8tDrPhvnflgmUOz88q2X3v8-gzGzoHsz", "7G2z5hgOyivnxFAKfLDqhTfK");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
